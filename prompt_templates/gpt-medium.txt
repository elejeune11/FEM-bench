MASTER INSTRUCTIONS FOR "PYTHON FUNCTION IMPLEMENTATION TASK" PROMPTS

What you will receive
- A prompt specifying a single Python function to implement with an exact signature and docstring.
- A strict list of allowed imports and, optionally, a list of helper functions available for use.
- Domain-specific requirements embedded in the docstring or in the task description.

Universal rules
- Keep the function name, parameter names, annotations, and the entire docstring exactly as given. Do not modify them.
- Do not add any code outside the function definition. Do not add comments, prints, tests, or extra top-level helpers.
- Use only the imports explicitly listed in the task. If imports are listed, assume they are available; if you import them inside the function, import only from the allowed list.
- If specific helper functions are listed as “Available Helper Functions,” you must call them rather than re-implementing them.
- If no helper functions are provided but the docstring requires standard building blocks, you may implement the minimal helper logic inside the function body (no code outside the function).
- Output only valid Python code consisting of the complete function definition — no explanations, markdown, or extra text.
- Implement exactly what the docstring and task description specify. If specific error conditions or Raises are documented, implement them precisely.
- Ensure all returned values, array shapes, indices, ordering, and data structures match the docstring’s specification exactly.
- Deterministic behavior only; no randomness or I/O.
- Use standard NumPy idioms. Keep shapes consistent; when assembling matrices, use np.ix_ for block adds where appropriate.
- Assume node indices are 0-based unless a prompt explicitly says otherwise. Do not remap indices.
- Convert numeric inputs to float arrays where appropriate to avoid dtype surprises, but do not add extra validation beyond what is specified.

General domain formulations and exact behaviors to follow

A) 1D uniform mesh generator (FEM_1D_uniform_mesh_CC0_H0_T0)
- num_nodes = num_elements + 1
- node_coords = np.linspace(x_min, x_max, num_nodes)
- element_connectivity is a (num_elements, 2) int array where each row is [e, e+1] for e in 0..num_elements-1
- Return (node_coords, element_connectivity) in that order
- Keep node indices increasing monotonically and elements numbered 0..num_elements-1

B) 3D frame DOF ordering and transformation
- Per 2-node beam element, local DOF order:
  [u1, v1, w1, θx1, θy1, θz1, u2, v2, w2, θx2, θy2, θz2]
- Internal end force/moment order:
  [Fx_i, Fy_i, Fz_i, Mx_i, My_i, Mz_i, Fx_j, Fy_j, Fz_j, Mx_j, My_j, Mz_j]
- The 12×12 direction-cosine transformation Γ maps:
  u_local = Γ @ u_global
  K_global = Γ.T @ K_local @ Γ
- If no helper is provided, implement beam_transformation_matrix_3D like this:
  1) Compute ex = (xj−xi, yj−yi, zj−zi) / L, L = norm of the difference; raise ValueError on zero length
  2) Choose ref_vec:
     - If not provided: use global z unless ex is aligned with global z; then use global y
     - Validate: shape (3,), unit length, not parallel to ex (nonzero cross product); else raise ValueError
  3) ey = cross(ref_vec, ex) normalized; ez = cross(ex, ey)
  4) gamma = stack rows [ex; ey; ez] (3×3); Γ = kron(I4, gamma) (12×12)

C) Local elastic stiffness for Euler–Bernoulli 3D beam (if required and no helper provided)
- Inputs: E, nu, A, L, Iy, Iz, J
- Use:
  EA_L = E*A/L
  GJ_L = E*J/(2*(1+nu)*L)
  EIz = E*Iz; EIy = E*Iy
- Assemble standard 12×12 k_local entries exactly:
  - Axial:
    k[0,0] = k[6,6] = EA_L; k[0,6] = k[6,0] = -EA_L
  - Torsion:
    k[3,3] = k[9,9] = GJ_L; k[3,9] = k[9,3] = -GJ_L
  - Bending about local z (v-θz):
    k[1,1] = k[7,7] = 12*EIz/L**3
    k[1,7] = k[7,1] = -12*EIz/L**3
    k[1,5] = k[5,1] = k[1,11] = k[11,1] = 6*EIz/L**2
    k[5,7] = k[7,5] = k[7,11] = k[11,7] = -6*EIz/L**2
    k[5,5] = k[11,11] = 4*EIz/L
    k[5,11] = k[11,5] = 2*EIz/L
  - Bending about local y (w-θy):
    k[2,2] = k[8,8] = 12*EIy/L**3
    k[2,8] = k[8,2] = -12*EIy/L**3
    k[2,4] = k[4,2] = k[2,10] = k[10,2] = -6*EIy/L**2
    k[4,8] = k[8,4] = k[8,10] = k[10,8] = 6*EIy/L**2
    k[4,4] = k[10,10] = 4*EIy/L
    k[4,10] = k[10,4] = 2*EIy/L

D) Local internal element loads under a displacement state (MSA_3D_local_element_loads_CC0_H2_T1)
- Purpose: Compute local internal end forces from a given global element displacement vector
- Steps:
  1) Build Γ via beam_transformation_matrix_3D(xi,yi,zi,xj,yj,zj, ele_info.get('local_z'))
  2) u_dofs_local = Γ @ u_dofs_global  (note: not Γ.T)
  3) L = norm([xj−xi, yj−yi, zj−zi])
  4) k_e_local = local_elastic_stiffness_matrix_3D_beam(E, nu, A, L, I_y, I_z, J)
  5) load_dofs_local = k_e_local @ u_dofs_local
  6) Return load_dofs_local as shape (12,)
- Do not add extra validation beyond what the helper raises

E) Local geometric stiffness with torsion-bending coupling (MSA_3D_local_geometric_stiffness_CC1_H0_T0)
- Implement the full 12×12 geometric stiffness matrix exactly as:
  k_g = zeros((12,12))
  # upper triangle off-diagonals
  k_g[0, 6] = -Fx2 / L
  k_g[1, 3] = My1 / L
  k_g[1, 4] = Mx2 / L
  k_g[1, 5] = Fx2 / 10.0
  k_g[1, 7] = -6.0 * Fx2 / (5.0 * L)
  k_g[1, 9] = My2 / L
  k_g[1, 10] = -Mx2 / L
  k_g[1, 11] = Fx2 / 10.0
  k_g[2, 3] = Mz1 / L
  k_g[2, 4] = -Fx2 / 10.0
  k_g[2, 5] = Mx2 / L
  k_g[2, 8] = -6.0 * Fx2 / (5.0 * L)
  k_g[2, 9] = Mz2 / L
  k_g[2, 10] = -Fx2 / 10.0
  k_g[2, 11] = -Mx2 / L
  k_g[3, 4] = -1.0 * (2.0 * Mz1 - Mz2) / 6.0
  k_g[3, 5] = (2.0 * My1 - My2) / 6.0
  k_g[3, 7] = -My1 / L
  k_g[3, 8] = -Mz1 / L
  k_g[3, 9] = -Fx2 * I_rho / (A * L)
  k_g[3, 10] = -1.0 * (Mz1 + Mz2) / 6.0
  k_g[3, 11] = (My1 + My2) / 6.0
  k_g[4, 7] = -Mx2 / L
  k_g[4, 8] = Fx2 / 10.0
  k_g[4, 9] = -1.0 * (Mz1 + Mz2) / 6.0
  k_g[4, 10] = -Fx2 * L / 30.0
  k_g[4, 11] = Mx2 / 2.0
  k_g[5, 7] = -Fx2 / 10.0
  k_g[5, 8] = -Mx2 / L
  k_g[5, 9] = (My1 + My2) / 6.0
  k_g[5, 10] = -Mx2 / 2.0
  k_g[5, 11] = -Fx2 * L / 30.0
  k_g[7, 9] = -My2 / L
  k_g[7, 10] = Mx2 / L
  k_g[7, 11] = -Fx2 / 10.0
  k_g[8, 9] = -Mz2 / L
  k_g[8, 10] = Fx2 / 10.0
  k_g[8, 11] = Mx2 / L
  k_g[9, 10] = (Mz1 - 2.0 * Mz2) / 6.0
  k_g[9, 11] = -1.0 * (My1 - 2.0 * My2) / 6.0
  # symmetric lower triangle
  k_g = k_g + k_g.T
  # diagonal terms
  k_g[0, 0] = Fx2 / L
  k_g[1, 1] = 6.0 * Fx2 / (5.0 * L)
  k_g[2, 2] = 6.0 * Fx2 / (5.0 * L)
  k_g[3, 3] = Fx2 * I_rho / (A * L)
  k_g[4, 4] = 2.0 * Fx2 * L / 15.0
  k_g[5, 5] = 2.0 * Fx2 * L / 15.0
  k_g[6, 6] = Fx2 / L
  k_g[7, 7] = 6.0 * Fx2 / (5.0 * L)
  k_g[8, 8] = 6.0 * Fx2 / (5.0 * L)
  k_g[9, 9] = Fx2 * I_rho / (A * L)
  k_g[10, 10] = 2.0 * Fx2 * L / 15.0
  k_g[11, 11] = 2.0 * Fx2 * L / 15.0
- Return k_g as a 12×12 float ndarray

F) Global geometric stiffness assembly (MSA_3D_assemble_global_geometric_stiffness_CC1_H4_T3)
- Inputs: node_coords (n×3), elements (sequence of dicts), u_global (6n,)
- DOF per node: [u_x, u_y, u_z, θ_x, θ_y, θ_z]
- For each element:
  1) node_i, node_j as 0-based indices (do not shift)
  2) Extract xi,yi,zi, xj,yj,zj; compute L; validate nonzero (by helper or internal logic)
  3) Build Γ (see B)
  4) Construct local elastic stiffness k_e_local (helper if provided; else C)
  5) dofs_i = [6*i + d for d in range(6)], dofs_j similarly; dofs = dofs_i + dofs_j
  6) u_e_global = u_global[dofs]; u_local = Γ @ u_e_global
  7) f_local = k_e_local @ u_local
  8) End resultants:
     Fx2 = f_local[6]
     Mx2 = f_local[9]
     My1 = f_local[4]
     Mz1 = f_local[5]
     My2 = f_local[10]
     Mz2 = f_local[11]
     A = ele['A']; I_rho = ele['I_rho']
  9) k_g_local via (E)
  10) k_g_global = Γ.T @ k_g_local @ Γ
  11) Assemble: K[np.ix_(dofs, dofs)] += k_g_global
- Return K of shape (6*n_nodes, 6*n_nodes)

G) 1D linear elastic bar solver with meshing and assembly (FEM_1D_linear_elastic_CC0_H0_T0)
- Mesh as in (A)
- Element stiffness: ke = (E*A/Le) * [[1, -1], [-1, 1]]
- Material assignment by element midpoint must match exactly one region; else raise ValueError
- Gauss quadrature on [-1,1]:
  - n_gauss=1: xi=[0.0], w=[2.0]
  - n_gauss=2: xi=[-1/√3, 1/√3], w=[1.0, 1.0]
  - n_gauss=3: xi=[-√(3/5), 0.0, √(3/5)], w=[5/9, 8/9, 5/9]
- Mapping: x(ξ) = N1*x1 + N2*x2; N1=(1−ξ)/2, N2=(1+ξ)/2; J=Le/2
- Body force: fe += w * f(x_gp) * J * [N1, N2]
- Neumann BCs (optional): add loads to matching nodes (use small tolerance)
- Dirichlet BCs: reduce system, solve, back-substitute, compute reactions at constrained nodes
- Return dict with keys: "displacements", "reactions", "node_coords", "reaction_nodes" per spec
- If constraints are insufficient and the reduced system is singular, allow numpy.linalg to raise

H) Q8 element physical gradient mapping (FEM_2D_quad8_physical_gradient_CC0_H1_T3)
- Inputs:
  node_coords: (8,2) array with node ordering:
    1: (-1, -1), 2: (1, -1), 3: (1, 1), 4: (-1, 1),
    5: (0, -1), 6: (1, 0), 7: (0, 1), 8: (-1, 0)
  node_values: (8,) scalar nodal values
  xi, eta: scalar or array-like (n_pts,)
- Compute Q8 shape function derivatives with respect to ξ, η in order [N1..N8], using the exact formulas:
  Let x≡ξ, y≡η, one=1.0, xm=1−x, xp=1+x, ym=1−y, yp=1+y
  dN:
    dN1/dξ =  0.25 * ym * (2x + y)
    dN1/dη =  0.25 * xm * (x + 2y)
    dN2/dξ =  0.25 * ym * (2x - y)
    dN2/dη =  0.25 * xp * (2y - x)
    dN3/dξ =  0.25 * yp * (2x + y)
    dN3/dη =  0.25 * xp * (2y + x)
    dN4/dξ =  0.25 * yp * (2x - y)
    dN4/dη =  0.25 * xm * (2y - x)
    dN5/dξ = -x * ym
    dN5/dη = -0.5 * (1 - x^2)
    dN6/dξ =  0.5 * (1 - y^2)
    dN6/dη = -(1 + x) * y
    dN7/dξ = -x * yp
    dN7/dη =  0.5 * (1 - x^2)
    dN8/dξ = -0.5 * (1 - y^2)
    dN8/dη = -(1 - x) * y
- For each evaluation point p:
  - dN_p: (8,2); grad_nat_p = dN_p.T @ node_values  → (2,)
  - J_p = node_coords.T @ dN_p  → (2,2), where columns correspond to ∂(x,y)/∂(ξ,η)
  - Map to physical gradient via: grad_phys[:, p] = (J_p^{-T}) @ grad_nat_p
    Equivalently solve J_p.T * grad_phys = grad_nat_p
- Accept scalar or array inputs; broadcast to n_pts; return grad_phys with shape (2, n_pts)
- Do not add extra validation beyond shapes and linear algebra

I) Global load vector assembly for 3D frame (MSA_3D_assemble_global_load_CC0_H0_T0)
- Inputs: nodal_loads: dict[int, array-like of 6], n_nodes: int
- DOF ordering per node: [UX, UY, UZ, RX, RY, RZ]
- Create P = zeros(6*n_nodes); for each (node, load) place/add the 6 values into slice [6*n : 6*n+6]
- Convert loads to float; nodes not listed remain zeros
- Return P as (6*n_nodes,) ndarray

J) Smallest positive buckling factor and mode (MSA_3D_solve_eigenvalue_CC1_H1_T1)
- Use helper partition_degrees_of_freedom(boundary_conditions, n_nodes) to obtain fixed, free DOFs
- Extract reduced matrices: K_e_ff = K_e[np.ix_(free,free)], K_g_ff = K_g[np.ix_(free,free)]
- Conditioning checks: if cond(K_e_ff) or cond(K_g_ff) is non-finite or > 1e16, raise ValueError
- Solve the generalized eigenproblem:
  K_e_ff * phi = -lambda * K_g_ff * phi
  using scipy.linalg.eig(K_e_ff, -K_g_ff)
- Ensure eigenpairs are effectively real:
  - Either use np.real_if_close(tol=1e3) and verify no complex remains
  - Or enforce imag parts below a small relative tolerance (e.g., 1e-8) and raise if not
- Select the smallest positive eigenvalue (lambda > 0). If none found, raise ValueError
- Take the corresponding eigenvector (real part if applicable) and embed back into a global vector of length 6*n_nodes, with zeros at fixed DOFs
- Return (elastic_critical_load_factor, deformed_shape_vector). No normalization of the mode

Additional guidance and common pitfalls
- Use u_local = Γ @ u_global (not Γ.T @ u_global) when mapping displacements to local.
- Use Γ.T @ K_local @ Γ to map stiffness to global.
- Do not simplify the geometric stiffness to axial P-Δ only; include torsion–bending coupling and end-moment terms exactly as specified in (E).
- When assembling global matrices, always use np.ix_ for block operations to avoid broadcasting errors.
- Respect the specified DOF order [u_x, u_y, u_z, θ_x, θ_y, θ_z] consistently across all operations.
- For mesh generators and assemblers, keep indices 0-based and strictly monotonic where specified.
- When the docstring specifies specific errors to raise, implement them exactly; otherwise avoid extraneous validation.

Output format
- Return only the complete Python function definition as valid code. No extra text, comments, or formatting.