{
    "function_imports": [
      "numpy",
      "scipy"
    ],
    "element_body_force_vector_1D": "import numpy as np\nfrom typing import Callable\nfrom T1_NI_001 import gauss_quadrature_1D\nfrom T1_SF_001 import shape_functions_1D_linear\nfrom T1_FE_001 import compute_jacobian_1D\n\ndef element_body_force_vector_1D(x_elem: np.ndarray, body_force_fn: Callable[[float], float], n_gauss: int) -> np.ndarray:\n    \"\"\"\n    Compute the element body force vector for a 1D finite element using numerical integration and shape functions.\n\n    Args:\n        x_elem (np.ndarray): Element node coordinates (shape: (2,)).\n        body_force_fn (Callable): Function that returns the body force value at a given point.\n        n_gauss (int): Number of Gauss quadrature points to use.\n\n    Returns:\n        np.ndarray: Element body force vector (shape: (2,)).\n    \"\"\"\n    gauss_points, gauss_weights = gauss_quadrature_1D(n_gauss)\n    element_body_force = np.zeros(2)\n    for i in range(n_gauss):\n        xi = gauss_points[i]\n        w = gauss_weights[i]\n        N = shape_functions_1D_linear(xi)\n        # Jacobian calculation\n        dN_dxi = np.array([[-0.5, 0.5]]) # Derivatives are constant for linear shape functions\n        J = compute_jacobian_1D(dN_dxi, x_elem)\n        x = 0.5 * (x_elem[0] + x_elem[1]) + 0.5 * (x_elem[1] - x_elem[0]) * xi # x = sum(N_i * x_i)\n        f = body_force_fn(x)\n        element_body_force += N * f * w * J\n    return element_body_force\n",
    "test_imports": [
      "pytest",
      "numpy"
    ],
    "test_constant_body_force": "import numpy as np\nfrom T1_NI_001 import gauss_quadrature_1D\nfrom T1_SF_001 import shape_functions_1D_linear\nfrom T1_FE_001 import compute_jacobian_1D\nfrom typing import Callable\n\n# Assuming element_body_force_vector_1D is defined in the same scope or imported\n\ndef test_constant_body_force():\n    \"\"\"\n    Test the element_body_force_vector_1D function with a constant body force.\n    \"\"\"\n    x_elem = np.array([0.0, 1.0])\n    body_force_value = 10.0\n    n_gauss = 2\n\n    def body_force_fn(x: float) -> float:\n        return body_force_value\n\n    element_body_force = element_body_force_vector_1D(x_elem, body_force_fn, n_gauss)\n\n    # Expected result: \n    # For a constant body force, the integral simplifies to the body force * element length / 2 for each node\n    expected_element_body_force = np.array([body_force_value * 0.5 * 0.5, body_force_value * 0.5 * 0.5]) #element length is 1\n\n    assert np.allclose(element_body_force, expected_element_body_force, rtol=1e-5)\n",
    "test_linear_body_force": "import numpy as np\nfrom T1_NI_001 import gauss_quadrature_1D\nfrom T1_SF_001 import shape_functions_1D_linear\nfrom T1_FE_001 import compute_jacobian_1D\nfrom typing import Callable\n\n# Assuming element_body_force_vector_1D is defined in the same scope or imported\n\ndef test_linear_body_force():\n    \"\"\"\n    Test the element_body_force_vector_1D function with a linear body force.\n    \"\"\"\n    x_elem = np.array([0.0, 1.0])\n    # Define a linear body force: f(x) = x\n    def body_force_fn(x: float) -> float:\n        return x\n\n    n_gauss = 2\n    element_body_force = element_body_force_vector_1D(x_elem, body_force_fn, n_gauss)\n    # Analytical solution for linear body force f(x) = x, over element [0, 1]\n    #  Integral(N1 * x dx) from 0 to 1, and integral (N2 * x dx) from 0 to 1 where N1 = 1-x and N2 = x.\n    # Node 1:  Integral( (1-x)*x dx) = integral (x - x^2) dx = x^2/2 - x^3/3 from 0 to 1 = 1/2 - 1/3 = 1/6\n    # Node 2: Integral(x*x dx) = integral(x^2) dx = x^3/3 from 0 to 1 = 1/3\n    expected_element_body_force = np.array([1/6, 1/3])\n    assert np.allclose(element_body_force, expected_element_body_force, rtol=1e-5)\n"
  }