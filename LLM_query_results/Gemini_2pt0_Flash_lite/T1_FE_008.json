{
    "function_imports": [
      "numpy",
      "scipy"
    ],
    "solve_linear_elastic_1D": "def solve_linear_elastic_1D(node_coords: np.ndarray, element_connectivity: np.ndarray, prop_list: list, body_force_fn: callable, dirichlet_BC_locations: list, prescribed_displacements: list, neumann_bc_list: list, n_gauss: int) -> np.ndarray:\n    \"\"\"Solves a 1D linear elastic finite element problem with mixed boundary conditions.\n\n    Args:\n        node_coords (np.ndarray): Coordinates of the nodes.\n        element_connectivity (np.ndarray): Connectivity of the elements.\n        prop_list (list): List of material properties (E, A) for each spatial region.\n        body_force_fn (callable): Function to compute the body force.\n        dirichlet_BC_locations (list): Locations of Dirichlet boundary conditions.\n        prescribed_displacements (list): Prescribed displacements for Dirichlet BCs.\n        neumann_bc_list (list): List of Neumann boundary conditions (location, traction).\n        n_gauss (int): Number of Gauss points for numerical integration.\n\n    Returns:\n        np.ndarray: Solution vector (displacements) and reaction forces.\n    \"\"\"\n    import numpy as np\n    from typing import Callable, List, Dict\n    from scipy.sparse import csr_matrix\n    from scipy.sparse.linalg import spsolve\n\n    # Assign element properties\n    E_vector, A_vector = assign_element_props_linear_elastic_1D(prop_list, node_coords, element_connectivity)\n\n    # Assemble global stiffness matrix\n    K_global = assemble_global_stiffness_matrix_linear_elastic_1D(node_coords, element_connectivity, E_vector, A_vector, n_gauss)\n\n    # Assemble global body force vector\n    F_global = assemble_global_body_force_vector_linear_elastic_1D(node_coords, element_connectivity, body_force_fn, n_gauss)\n\n    # Apply Neumann boundary conditions\n    for bc in neumann_bc_list:\n        node_index = np.argmin(np.abs(node_coords - bc['location']))\n        F_global[node_index] += bc['traction']\n\n    # Apply Dirichlet boundary conditions\n    dirichlet_BC_nodes = [np.argmin(np.abs(node_coords - loc)) for loc in dirichlet_BC_locations]\n\n    # Solve the system\n    solution = solve_matrix_eqn(K_global, F_global, dirichlet_BC_nodes, np.array(prescribed_displacements))\n    return solution",
    "test_imports": [
      "pytest",
      "numpy",
      "scipy"
    ],
    "test_no_load": "def test_no_load():\n    import numpy as np\n    from scipy.sparse import csr_matrix\n\n    # Define a simple problem\n    node_coords = np.array([0.0, 1.0])\n    element_connectivity = np.array([[0, 1]])\n    prop_list = [{'E': 1.0, 'A': 1.0, 'region': [0.0, 1.0]}]\n    body_force_fn = lambda x: 0.0\n    dirichlet_BC_locations = [0.0]\n    prescribed_displacements = [0.0]\n    neumann_bc_list = []\n    n_gauss = 2\n\n    # Solve the problem\n    from T1_FE_002 import assign_element_props_linear_elastic_1D\n    from T1_FE_005 import assemble_global_stiffness_matrix_linear_elastic_1D\n    from T1_FE_006 import assemble_global_body_force_vector_linear_elastic_1D\n    from T1_FE_007 import solve_matrix_eqn\n    from solve_linear_elastic_1D import solve_linear_elastic_1D\n    solution = solve_linear_elastic_1D(node_coords, element_connectivity, prop_list, body_force_fn, dirichlet_BC_locations, prescribed_displacements, neumann_bc_list, n_gauss)\n    x = solution[0]\n    # Check solution (should be zero displacement everywhere)\n    assert np.allclose(x, [0.0, 0.0])\n",
    "test_uniform_extension_analytical": "def test_uniform_extension_analytical():\n    import numpy as np\n    from scipy.sparse import csr_matrix\n\n    # Define problem parameters\n    L = 1.0  # Length\n    E = 1.0  # Young's modulus\n    A = 1.0  # Area\n    F = 1.0  # Applied force\n\n    # FEA Setup\n    node_coords = np.array([0.0, L])\n    element_connectivity = np.array([[0, 1]])\n    prop_list = [{'E': E, 'A': A, 'region': [0.0, L]}]\n    body_force_fn = lambda x: 0.0\n    dirichlet_BC_locations = [0.0]\n    prescribed_displacements = [0.0]\n    neumann_bc_list = [{'location': L, 'traction': F / A}]\n    n_gauss = 2\n\n    # Solve\n    from T1_FE_002 import assign_element_props_linear_elastic_1D\n    from T1_FE_005 import assemble_global_stiffness_matrix_linear_elastic_1D\n    from T1_FE_006 import assemble_global_body_force_vector_linear_elastic_1D\n    from T1_FE_007 import solve_matrix_eqn\n    from solve_linear_elastic_1D import solve_linear_elastic_1D\n    solution = solve_linear_elastic_1D(node_coords, element_connectivity, prop_list, body_force_fn, dirichlet_BC_locations, prescribed_displacements, neumann_bc_list, n_gauss)\n    x = solution[0]\n\n    # Analytical Solution\n    analytical_displacement = F * L / (E * A)\n    #print(f\"FEA Displacement: {x[1]}, Analytical Displacement: {analytical_displacement}\")\n\n    # Assert (check displacement at x=L)\n    assert np.isclose(x[1], analytical_displacement)\n",
    "test_multi_material_system": "def test_multi_material_system():\n    import numpy as np\n    from scipy.sparse import csr_matrix\n\n    # Define the problem\n    node_coords = np.array([0.0, 0.5, 1.0])\n    element_connectivity = np.array([[0, 1], [1, 2]])\n    prop_list = [\n        {'E': 1.0, 'A': 1.0, 'region': [0.0, 0.5]},\n        {'E': 2.0, 'A': 1.0, 'region': [0.5, 1.0]}\n    ]\n    body_force_fn = lambda x: 0.0\n    dirichlet_BC_locations = [0.0]\n    prescribed_displacements = [0.0]\n    neumann_bc_list = [{'location': 1.0, 'traction': 1.0}]\n    n_gauss = 2\n\n    # Solve the problem\n    from T1_FE_002 import assign_element_props_linear_elastic_1D\n    from T1_FE_005 import assemble_global_stiffness_matrix_linear_elastic_1D\n    from T1_FE_006 import assemble_global_body_force_vector_linear_elastic_1D\n    from T1_FE_007 import solve_matrix_eqn\n    from solve_linear_elastic_1D import solve_linear_elastic_1D\n    solution = solve_linear_elastic_1D(node_coords, element_connectivity, prop_list, body_force_fn, dirichlet_BC_locations, prescribed_displacements, neumann_bc_list, n_gauss)\n    x = solution[0]\n    # Check the solution\n    # Note: This requires knowing the analytical solution, or we can define an acceptable range and assert\n    assert np.isclose(x[2], 0.75)\n",
    "test_neumann_point_load": "def test_neumann_point_load():\n    import numpy as np\n    from scipy.sparse import csr_matrix\n\n    # Define the problem\n    L = 1.0  # Length\n    E = 1.0  # Young's modulus\n    A = 1.0  # Area\n    F = 1.0  # Applied force\n\n    node_coords = np.array([0.0, L])\n    element_connectivity = np.array([[0, 1]])\n    prop_list = [{'E': E, 'A': A, 'region': [0.0, L]}]\n    body_force_fn = lambda x: 0.0\n    dirichlet_BC_locations = [0.0]\n    prescribed_displacements = [0.0]\n    neumann_bc_list = [{'location': L, 'traction': F / A}]\n    n_gauss = 2\n\n    # Solve the problem\n    from T1_FE_002 import assign_element_props_linear_elastic_1D\n    from T1_FE_005 import assemble_global_stiffness_matrix_linear_elastic_1D\n    from T1_FE_006 import assemble_global_body_force_vector_linear_elastic_1D\n    from T1_FE_007 import solve_matrix_eqn\n    from solve_linear_elastic_1D import solve_linear_elastic_1D\n    solution = solve_linear_elastic_1D(node_coords, element_connectivity, prop_list, body_force_fn, dirichlet_BC_locations, prescribed_displacements, neumann_bc_list, n_gauss)\n    x = solution[0]\n\n    # Analytical solution\n    analytical_displacement = F * L / (E * A)\n    assert np.isclose(x[1], analytical_displacement)\n",
    "test_multiple_neumann_loads": "def test_multiple_neumann_loads():\n    import numpy as np\n    from scipy.sparse import csr_matrix\n\n    # Define the problem\n    L = 1.0  # Length\n    E = 1.0  # Young's modulus\n    A = 1.0  # Area\n    F1 = 0.5  # Applied force 1\n    F2 = 0.5  # Applied force 2\n\n    node_coords = np.array([0.0, 0.5, 1.0])\n    element_connectivity = np.array([[0, 1], [1, 2]])\n    prop_list = [{'E': E, 'A': A, 'region': [0.0, L]}]\n    body_force_fn = lambda x: 0.0\n    dirichlet_BC_locations = [0.0]\n    prescribed_displacements = [0.0]\n    neumann_bc_list = [\n        {'location': 0.5, 'traction': F1 / A},\n        {'location': 1.0, 'traction': F2 / A}\n    ]\n    n_gauss = 2\n\n    # Solve the problem\n    from T1_FE_002 import assign_element_props_linear_elastic_1D\n    from T1_FE_005 import assemble_global_stiffness_matrix_linear_elastic_1D\n    from T1_FE_006 import assemble_global_body_force_vector_linear_elastic_1D\n    from T1_FE_007 import solve_matrix_eqn\n    from solve_linear_elastic_1D import solve_linear_elastic_1D\n    solution = solve_linear_elastic_1D(node_coords, element_connectivity, prop_list, body_force_fn, dirichlet_BC_locations, prescribed_displacements, neumann_bc_list, n_gauss)\n    x = solution[0]\n\n    #Analytical solution - displacement at x = 0.5 should be F1*0.5/(E*A) and at x = 1.0 should be (F1*0.5+F2*0.5)/(E*A) = 0.5 / (E*A)\n    analytical_displacement_05 = (F1*0.5)/(E*A)\n    analytical_displacement_1 = (F1*0.5 + F2*0.5)/(E*A) # correct the calculation\n\n    assert np.isclose(x[1], analytical_displacement_05) # check displacement at 0.5\n    assert np.isclose(x[2], analytical_displacement_1) # check displacement at 1.0"
  }