{
    "function_imports": [
      "numpy"
    ],
    "solve_matrix_eqn": "import numpy as np\n\ndef solve_matrix_eqn(K_global: np.ndarray, F_global: np.ndarray, dirichlet_BC_nodes: list[int], prescribed_displacements: np.ndarray) -> np.ndarray:\n    \"\"\"Solves the global finite element system with prescribed displacement boundary conditions.\n\n    Args:\n        K_global (np.ndarray): Global stiffness matrix.\n        F_global (np.ndarray): Global force vector.\n        dirichlet_BC_nodes (List[int]): List of nodes with Dirichlet boundary conditions (fixed displacements).\n        prescribed_displacements (np.ndarray): Prescribed displacement values for the Dirichlet nodes.\n\n    Returns:\n        np.ndarray: Solution vector x, and reaction forces R\n    \"\"\"\n\n    # Create a copy to avoid modifying the original matrices\n    K = K_global.copy()\n    F = F_global.copy()\n\n    # Apply Dirichlet boundary conditions\n    for i, node in enumerate(dirichlet_BC_nodes):\n        # Set rows and columns corresponding to the boundary nodes to zero, except the diagonal\n        K[node, :] = 0\n        K[:, node] = 0\n        K[node, node] = 1  # Set diagonal to 1\n        F[node] = prescribed_displacements[i] #Set force vector to displacement\n\n    # Solve for displacements\n    x = np.linalg.solve(K, F)\n\n    # Calculate reaction forces (R = K * x - F)\n    R = K_global @ x - F_global\n\n    return np.array([x, R])",
    "test_imports": [
      "pytest",
      "numpy"
    ],
    "test_solve_matrix_eqn": "import numpy as np\nimport pytest\nfrom typing import List\n\n\ndef test_solve_matrix_eqn():\n    \"\"\"Tests the solve_matrix_eqn function.\"\"\"\n\n    # Test case 1\n    K_global = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\n    F_global = np.array([0, 0, 1])\n    dirichlet_BC_nodes = [0]\n    prescribed_displacements = np.array([0])\n    [x, R] = solve_matrix_eqn(K_global, F_global, dirichlet_BC_nodes, prescribed_displacements)\n\n    assert np.allclose(x, np.array([0.0, 0.5, 1.0]))\n    assert np.allclose(R, np.array([ -0.5, 0.0, 0.0]))\n\n    # Test case 2: more complex BC\n    K_global = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\n    F_global = np.array([0, 1, 0])\n    dirichlet_BC_nodes = [0, 2]\n    prescribed_displacements = np.array([0, 0])\n    [x, R] = solve_matrix_eqn(K_global, F_global, dirichlet_BC_nodes, prescribed_displacements)\n\n    assert np.allclose(x, np.array([0.0, 0.5, 0.0]))\n    assert np.allclose(R, np.array([-0.5, 0.0, 0.5]))\n\n    # Test case 3: No BC\n    K_global = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\n    F_global = np.array([0, 1, 0])\n    dirichlet_BC_nodes = []\n    prescribed_displacements = np.array([])\n    [x, R] = solve_matrix_eqn(K_global, F_global, dirichlet_BC_nodes, prescribed_displacements)\n    #The solution here will not be unique, but we should get a reasonable solution\n\n    # Test case 4: Multiple BC nodes\n    K_global = np.array([[4, -1, -1, -1], [-1, 4, -1, -1], [-1, -1, 4, -1], [-1, -1, -1, 4]])\n    F_global = np.array([1, 2, 3, 4])\n    dirichlet_BC_nodes = [0, 2]  # Nodes with fixed displacements\n    prescribed_displacements = np.array([0, 1])\n    [x, R] = solve_matrix_eqn(K_global, F_global, dirichlet_BC_nodes, prescribed_displacements)\n    assert np.allclose(x, np.array([0.0, 1.125, 1.0, 1.375]))\n    assert np.allclose(R, np.array([-1.875, -1.125, -0.0, -1.125]))"
  }