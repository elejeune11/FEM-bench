{
    "function_imports": [
      "numpy",
      "scipy",
      "typing"
    ],
    "solve_linear_elastic_1D_self_contained": "import numpy as np\nfrom scipy.integrate import quad\nfrom typing import List, Dict, Callable\n\ndef solve_linear_elastic_1D_self_contained(x_min: float, x_max: float, num_elements: int, prop_list: List[Dict[str, float]], body_force_fn: Callable[[float], float], dirichlet_BC_locations: List[float], prescribed_displacements: List[float], neumann_bc_list: List[Dict[str, float]], n_gauss: int) -> np.ndarray:\n    '''\n    Self-contained 1D linear elastic finite element solver.\n\n    Args:\n        x_min (float): Minimum x-coordinate.\n        x_max (float): Maximum x-coordinate.\n        num_elements (int): Number of elements.\n        prop_list (List[Dict[str, float]]): List of material properties for each element. Each dict must contain 'E' (Young's modulus).\n        body_force_fn (Callable[[float], float]): Body force function.\n        dirichlet_BC_locations (List[float]): Locations of Dirichlet boundary conditions.\n        prescribed_displacements (List[float]): Prescribed displacements for Dirichlet BCs.\n        neumann_bc_list (List[Dict[str, float]]): List of Neumann boundary conditions. Each dict must contain 'location' (x-coordinate) and 'traction' (traction value).\n        n_gauss (int): Number of Gauss points for integration.\n\n    Returns:\n        np.ndarray: Array containing [x, R], where x are the node coordinates and R are the reaction forces.\n    '''\n    # Mesh generation\n    element_size = (x_max - x_min) / num_elements\n    node_coords = np.linspace(x_min, x_max, num_elements + 1)\n\n    # Element connectivity\n    element_connectivity = np.array([[i, i + 1] for i in range(num_elements)])\n\n    # Gauss quadrature points and weights\n    if n_gauss == 1:\n        gauss_points = np.array([0.0])\n        gauss_weights = np.array([2.0])\n    elif n_gauss == 2:\n        gauss_points = np.array([-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)])\n        gauss_weights = np.array([1.0, 1.0])\n    elif n_gauss == 3:\n        gauss_points = np.array([-np.sqrt(3.0/5.0), 0.0, np.sqrt(3.0/5.0)])\n        gauss_weights = np.array([5.0/9.0, 8.0/9.0, 5.0/9.0])\n    else:\n        raise ValueError(\"Unsupported number of Gauss points\")\n\n    # Initialize global stiffness matrix and force vector\n    num_nodes = num_elements + 1\n    K = np.zeros((num_nodes, num_nodes))\n    F = np.zeros(num_nodes)\n\n    # Element-wise computations\n    for element_index in range(num_elements):\n        # Element nodes\n        node1, node2 = element_connectivity[element_index]\n        x1, x2 = node_coords[node1], node_coords[node2]\n\n        # Element properties\n        element_prop = prop_list[element_index % len(prop_list)] # Account for multi-material cases with repeating material\n        E = element_prop['E']\n\n        # Element stiffness matrix\n        Ke = (E / element_size) * np.array([[1, -1], [-1, 1]])\n\n        # Assemble element stiffness matrix into global stiffness matrix\n        K[node1, node1] += Ke[0, 0]\n        K[node1, node2] += Ke[0, 1]\n        K[node2, node1] += Ke[1, 0]\n        K[node2, node2] += Ke[1, 1]\n\n        # Element force vector - body force\n        for i in range(n_gauss):\n            xi = gauss_points[i]\n            wi = gauss_weights[i]\n            x_gauss = 0.5 * (x2 - x1) * xi + 0.5 * (x1 + x2)\n            N1 = 0.5 * (1 - xi)\n            N2 = 0.5 * (1 + xi)\n            Fe_body_force = wi * body_force_fn(x_gauss) * 0.5 * (x2 - x1) * np.array([N1, N2])\n            F[node1] += Fe_body_force[0]\n            F[node2] += Fe_body_force[1]\n\n    # Apply Neumann boundary conditions\n    for bc in neumann_bc_list:\n        location = bc['location']\n        traction = bc['traction']\n        # Find the nearest node.  If we have a Neumann condition *at* a node, add it there.\n        node_index = np.argmin(np.abs(node_coords - location))\n        F[node_index] += traction  # Applied at the location\n\n    # Apply Dirichlet boundary conditions\n    for i, location in enumerate(dirichlet_BC_locations):\n        displacement = prescribed_displacements[i]\n        node_index = np.argmin(np.abs(node_coords - location))\n        # Modify stiffness matrix and force vector\n        K[node_index, :] = 0\n        K[:, node_index] = 0\n        K[node_index, node_index] = 1\n        F[node_index] = displacement\n\n    # Solve for displacements\n    try:\n        u = np.linalg.solve(K, F)\n    except np.linalg.LinAlgError:\n        print(\"Singular stiffness matrix.  Check boundary conditions.\")\n        return np.array([node_coords, np.zeros_like(node_coords)])\n\n    # Calculate reaction forces\n    R = np.zeros_like(F)\n    for i in range(num_nodes):\n      R[i] = F[i] - np.dot(K[:,i], u)\n\n    return np.array([node_coords, R])",
    "test_imports": [
      "pytest",
      "numpy",
      "typing"
    ],
    "test_no_load_self_contained": "import pytest\nimport numpy as np\nfrom typing import List, Dict, Callable\nfrom solve_linear_elastic_1D_self_contained import solve_linear_elastic_1D_self_contained\n\ndef test_no_load_self_contained():\n    '''\n    Test case: No load, fixed-fixed beam.  Should result in zero displacement and zero reaction forces.\n    '''\n    x_min, x_max = 0.0, 1.0\n    num_elements = 10\n    E = 2e11 # Young's modulus (Pa)\n    prop_list: List[Dict[str, float]] = [{'E': E}]\n    body_force_fn: Callable[[float], float] = lambda x: 0.0 # No body force\n    dirichlet_BC_locations = [0.0, 1.0]\n    prescribed_displacements = [0.0, 0.0]\n    neumann_bc_list: List[Dict[str, float]] = []\n    n_gauss = 2\n\n    result = solve_linear_elastic_1D_self_contained(x_min, x_max, num_elements, prop_list, body_force_fn, dirichlet_BC_locations, prescribed_displacements, neumann_bc_list, n_gauss)\n    x, R = result\n    assert np.allclose(R, [0.0] * (num_elements+1), atol=1e-6), \"Reaction forces should be zero.\"\n    assert np.allclose(R, [0,0,0,0,0,0,0,0,0,0,0], atol=1e-6)\n    assert np.allclose(x, np.linspace(0,1,11))\n\n",
    "test_uniform_extension_self_contained": "import pytest\nimport numpy as np\nfrom typing import List, Dict, Callable\nfrom solve_linear_elastic_1D_self_contained import solve_linear_elastic_1D_self_contained\n\ndef test_uniform_extension_self_contained():\n    '''\n    Test case: Uniform extension with fixed-free end.  Check that the reaction force at fixed end equals the applied Neumann traction.\n    '''\n    x_min, x_max = 0.0, 1.0\n    num_elements = 10\n    E = 2e11 # Young's modulus (Pa)\n    prop_list: List[Dict[str, float]] = [{'E': E}]\n    body_force_fn: Callable[[float], float] = lambda x: 0.0 # No body force\n    dirichlet_BC_locations = [0.0]\n    prescribed_displacements = [0.0]\n    neumann_bc_list: List[Dict[str, float]] = [{'location': 1.0, 'traction': 1000.0}] # Applied traction\n    n_gauss = 2\n\n    result = solve_linear_elastic_1D_self_contained(x_min, x_max, num_elements, prop_list, body_force_fn, dirichlet_BC_locations, prescribed_displacements, neumann_bc_list, n_gauss)\n    x, R = result\n    assert np.allclose(R[0], -1000.0, atol=1e-2), \"Reaction force at fixed end should equal negative of applied traction.\"\n",
    "test_multi_material_self_contained": "import pytest\nimport numpy as np\nfrom typing import List, Dict, Callable\nfrom solve_linear_elastic_1D_self_contained import solve_linear_elastic_1D_self_contained\n\ndef test_multi_material_self_contained():\n    '''\n    Test case: Two-material bar with fixed-free boundary conditions and a traction at the free end. Verify reaction force is correct.\n    '''\n    x_min, x_max = 0.0, 1.0\n    num_elements = 10\n    E1 = 2e11 # Young's modulus (Pa) - material 1\n    E2 = 4e11 # Young's modulus (Pa) - material 2\n    prop_list: List[Dict[str, float]] = [{'E': E1}, {'E': E2}] # Alternate between materials\n    body_force_fn: Callable[[float], float] = lambda x: 0.0\n    dirichlet_BC_locations = [0.0]\n    prescribed_displacements = [0.0]\n    neumann_bc_list: List[Dict[str, float]] = [{'location': 1.0, 'traction': 1000.0}]\n    n_gauss = 2\n\n    result = solve_linear_elastic_1D_self_contained(x_min, x_max, num_elements, prop_list, body_force_fn, dirichlet_BC_locations, prescribed_displacements, neumann_bc_list, n_gauss)\n    x, R = result\n    assert np.allclose(R[0], -1000.0, atol=1e-2), \"Reaction force should be equal to the negative of applied traction.\"\n",
    "test_neumann_loads_self_contained": "import pytest\nimport numpy as np\nfrom typing import List, Dict, Callable\nfrom solve_linear_elastic_1D_self_contained import solve_linear_elastic_1D_self_contained\n\ndef test_neumann_loads_self_contained():\n    '''\n    Test case: Neumann loads applied at two locations on a bar.  The reaction force at the fixed end should equal the sum of the tractions (with negative sign).\n    '''\n    x_min, x_max = 0.0, 1.0\n    num_elements = 10\n    E = 2e11 # Young's modulus (Pa)\n    prop_list: List[Dict[str, float]] = [{'E': E}]\n    body_force_fn: Callable[[float], float] = lambda x: 0.0\n    dirichlet_BC_locations = [0.0]\n    prescribed_displacements = [0.0]\n    neumann_bc_list: List[Dict[str, float]] = [\n        {'location': 0.25, 'traction': 500.0},\n        {'location': 0.75, 'traction': 500.0}\n    ]\n    n_gauss = 2\n\n    result = solve_linear_elastic_1D_self_contained(x_min, x_max, num_elements, prop_list, body_force_fn, dirichlet_BC_locations, prescribed_displacements, neumann_bc_list, n_gauss)\n    x, R = result\n    total_traction = sum([bc['traction'] for bc in neumann_bc_list])\n    assert np.allclose(R[0], -total_traction, atol=1e-2), \"Reaction force at fixed end should equal the negative sum of applied tractions.\"\n"
  }