def MSA_3D_assemble_global_geometric_stiffness_CC1_H4_T3(node_coords: np.ndarray, elements: Sequence[dict], u_global: np.ndarray) -> np.ndarray:
    n_nodes = node_coords.shape[0]
    n_dof = 6 * n_nodes
    K_global = np.zeros((n_dof, n_dof))
    for elem in elements:
        node_i = elem['node_i']
        node_j = elem['node_j']
        E = elem['E']
        nu = elem['nu']
        A = elem['A']
        Iy = elem['I_y']
        Iz = elem['I_z']
        J = elem['J']
        local_z_input = elem.get('local_z', None)
        (xi, yi, zi) = node_coords[node_i]
        (xj, yj, zj) = node_coords[node_j]
        dx = xj - xi
        dy = yj - yi
        dz = zj - zi
        L = np.sqrt(dx ** 2 + dy ** 2 + dz ** 2)
        lx = dx / L
        ly = dy / L
        lz = dz / L
        if local_z_input is not None:
            local_z = np.array(local_z_input)
        else:
            beam_axis = np.array([lx, ly, lz])
            global_z = np.array([0.0, 0.0, 1.0])
            dot_product = np.dot(beam_axis, global_z)
            if abs(abs(dot_product) - 1.0) < 1e-06:
                global_y = np.array([0.0, 1.0, 0.0])
                local_z = global_y
            else:
                local_z = global_z
        local_x = np.array([lx, ly, lz])
        local_y = np.cross(local_z, local_x)
        local_y = local_y / np.linalg.norm(local_y)
        local_z = np.cross(local_x, local_y)
        local_z = local_z / np.linalg.norm(local_z)
        Gamma = np.zeros((12, 12))
        R = np.array([local_x, local_y, local_z])
        for i in range(4):
            idx = i * 3
            Gamma[idx:idx + 3, idx:idx + 3] = R
        dof_indices = np.array([6 * node_i, 6 * node_i + 1, 6 * node_i + 2, 6 * node_i + 3, 6 * node_i + 4, 6 * node_i + 5, 6 * node_j, 6 * node_j + 1, 6 * node_j + 2, 6 * node_j + 3, 6 * node_j + 4, 6 * node_j + 5])
        u_elem_global = u_global[dof_indices]
        u_elem_local = Gamma @ u_elem_global
        k_local_elastic = np.zeros((12, 12))
        k_axial = E * A / L
        k_local_elastic[0, 0] = k_axial
        k_local_elastic[0, 6] = -k_axial
        k_local_elastic[6, 0] = -k_axial
        k_local_elastic[6, 6] = k_axial
        k_torsion = G = E / (2 * (1 + nu))
        k_torsion_val = G * J / L
        k_local_elastic[3, 3] = k_torsion_val
        k_local_elastic[3, 9] = -k_torsion_val
        k_local_elastic[9, 3] = -k_torsion_val
        k_local_elastic[9, 9] = k_torsion_val
        k_bend_y = 12 * E * Iz / L ** 3
        k_bend_y_rot = 6 * E * Iz / L ** 2
        k_bend_y_moment = 4 * E * Iz / L
        k_bend_y_moment2 = 2 * E * Iz / L
        k_local_elastic[1, 1] = k_bend_y
        k_local_elastic[1, 5] = k_bend_y_rot
        k_local_elastic[1, 7] = -k_bend_y
        k_local_elastic[1, 11] = k_bend_y_rot
        k_local_elastic[5, 1] = k_bend_y_rot
        k_local_elastic[5, 5] = k_bend_y_moment
        k_local_elastic[5, 7] = -k_bend_y_rot
        k_local_elastic[5, 11] = k_bend_y_moment2
        k_local_elastic[7, 1] = -k_bend_y
        k_local_elastic[7, 5] = -k_bend_y_rot
        k_local_elastic[7, 7] = k_bend_y
        k_local_elastic[7, 11] = -k_bend_y_rot
        k_local_elastic[11, 1] = k_bend_y_rot
        k_local_elastic[11, 5] = k_bend_y_moment2
        k_local_elastic[11, 7] = -k_bend_y_rot
        k_local_elastic[11, 11] = k_bend_y_moment
        k_bend_z = 12 * E * Iy / L ** 3
        k_bend_z_rot = 6 * E * Iy / L ** 2
        k_bend_z_moment = 4 * E * Iy / L
        k_bend_z_moment2 = 2 * E * Iy / L
        k_local_elastic[2, 2] = k_bend_z
        k_local_elastic[2, 4] = -k_bend_z_rot
        k_local_elastic[2, 8] = -k_bend_z
        k_local_elastic[2, 10] = -k_bend_z_rot
        k_local_elastic[4, 2] = -k_bend_z_rot
        k_local_elastic[4, 4] = k_bend_z_moment
        k_local_elastic[4, 8] = k_bend_z_rot
        k_local_elastic[4, 10] = k_bend_z_moment2
        k_local_elastic[8, 2] = -k_bend_z
        k_local_elastic[8, 4] = k_bend_z_rot
        k_local_elastic[8, 8] = k_bend_z
        k_local_elastic[8, 10] = k_bend_z_rot
        k_local_elastic[10, 2] = -k_bend_z_rot
        k_local_elastic[10, 4] = k_bend_z_moment2
        k_local_elastic[10, 8] = k_bend_z_rot
        k_local_elastic[10, 10] = k_bend_z_moment
        f_local = k_local_elastic @ u_elem_local
        Fx2 = f_local[6]
        k_g_local = np.zeros((12, 12))
        if abs(Fx2) > 1e-12:
            F = Fx2
            k_g_local[0, 0] = 0
            k_g_local[0, 6] = 0
            k_g_local[6, 0] = 0
            k_g_local[6, 6] = 0
            k_g_y_11 = F / L
            k_g_y_12 = F / 2
            k_g_y_22 = F * L / 4
            k_g_local[1, 1] = k_g_y_11
            k_g_local[1, 7] = -k_g_y_11
            k_g_local[7, 1] = -k_g_y_11
            k_g_local[7, 7] = k_g_y_11
            k_g_local[1, 5] = k_g_y_12 / L
            k_g_local[5, 1] = k_g_y_12 / L
            k_g_local[1, 11] = k_g_y_12 / L
            k_g_local[11, 1] = k_g_y_12 / L
            k_g_local[7, 5] = -k_g_y_12 / L
            k_g_local[5, 7] = -k_g_y_12 / L
            k_g_local[7, 11] = -k_g_y_12 / L
            k_g_local[11, 7] = -k_g_y_12 / L
            k_g_local[5, 5] = k_g_y_22
            k_g_local[5, 11] = k_g_y_22
            k_g_local[11, 5] = k_g_y_22
            k_g_local[11, 11] = k_g_y_22
            k_g_z_11 = F / L
            k_g_z_12 = F / 2
            k_g_z_22 = F * L / 4
            k_g_local[2, 2] = k_g_z_11
            k_g_local[2, 8] = -k_g_z_11
            k_g_local[8, 2] = -k_g_z_11
            k_g_local[8, 8] = k_g_z_11
            k_g_local[2, 4] = -k_g_z_12 / L
            k_g_local[4, 2] = -k_g_z_12 / L
            k_g_local[2, 10] = -k_g_z_12 / L
            k_g_local[10, 2] = -k_g_z_12 / L
            k_g_local[8, 4] = k_g_z_12 / L
            k_g_local[4, 8] = k_g_z_12 / L
            k_g_local[8, 10] = k_g_z_12 / L
            k_g_local[10, 8] = k_g_z_12 / L
            k_g_local[4, 4] = k_g_z_22
            k_g_local[4, 10] = k_g_z_22
            k_g_local[10, 4] = k_g_z_22
            k_g_local[10, 10] = k_g_z_22
            k_g_t_11 = F / L
            k_g_t_12 = F / 2
            k_g_local[3, 3] = k_g_t_11
            k_g_local[3, 9] = -k_g_t_11
            k_g_local[9, 3] = -k_g_t_11
            k_g_local[9, 9] = k_g_t_11
            k_g_local[3, 5] = k_g_t_12 / L
            k_g_local[5, 3] = k_g_t_12 / L
            k_g_local[3, 11] = -k_g_t_12 / L
            k_g_local[11, 3] = -k_g_t_12 / L
            k_g_local[9, 5] = -k_g_t_12 / L
            k_g_local[5, 9] = -k_g_t_12 / L
            k_g_local[9, 11] = k_g_t_12 / L
            k_g_local[11, 9] = k_g_t_12 / L
        k_g_global = Gamma.T @ k_g_local @ Gamma
        for i in range(12):
            for j in range(12):
                I = dof_indices[i]
                J = dof_indices[j]
                K_global[I, J] += k_g_global[i, j]
    return K_global