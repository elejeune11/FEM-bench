# Tier 1 Task Template
# Filename should match task_id: T1_FE_006.yaml
# Environment: Uses tier1_standard (see environments/tier1_environment.yaml)

# ============================================================================
# Task metadata
# ============================================================================
task_id: "T1_FE_006"
category: "FE"
subcategory: "assembly"
title: "Global Body Force Vector Assembly for 1D Linear Elastic Bar"
short_description: "Assemble the global body force vector from element contributions for a 1D finite element mesh."

version: "1.0"
created_date: "2025-06-19"
created_by: "elejeune11"

# ============================================================================
# Task specification -- note this forms the main LLM prompt
# ============================================================================

prompt: |
  Implement a function that assembles the global body force vector for a 1D linear elastic bar from individual element body force vectors.
  
  The global assembly process combines element-level force vectors into a system-level vector by mapping local element degrees of freedom to global degrees of freedom based on element connectivity.
  
  The assembly follows the standard finite element procedure:
  F_global[i] += f_element[a] where i is the global node ID and a is the local element node ID
  
  The function should satisfy:
  - Correct vector dimensions: (n_nodes,)
  - Conservation of total force: sum(F_global) = âˆ« body_force_fn(x) dx over domain
  - Single element case: should match element force vector exactly
  - Multiple elements: proper connectivity handling and force accumulation
  - Integration provides nodal equivalent forces; accuracy limited by linear representation within elements
  - Support for arbitrary body force functions f(x)
  
  Function input parameter definitions are:
    node_coords: 1D array of node coordinates (n_nodes,)
    element_connectivity: 2D array of element node connections (n_elements, 2)
    body_force_fn: Callable function f(x) defining the body force per unit length
    n_gauss: Number of Gauss integration points per element
  
  Include comprehensive unit tests that verify single element assembly, multi-element assembly with different force functions, and fundamental vector properties.

expected_function_name: "assemble_global_body_force_vector_linear_elastic_1D"
include_tests: true
expected_test_functions: ["test_global_body_force_single_element", "test_global_body_force_two_elements", "test_global_body_force_properties"]

function_signature:
  parameters: ["node_coords", "element_connectivity", "body_force_fn", "n_gauss"]
  parameter_types: ["np.ndarray", "np.ndarray", "Callable[[float], float]", "int"]
  return_shape: "(n_nodes,)"

task_dependencies:
  required_functions:
    - source_task: "T1_FE_004"

# ============================================================================
# Reference solutions and failure examples for evaluation testing
# ============================================================================

reference_solution:
  code: |
    def assemble_global_body_force_vector_linear_elastic_1D(
        node_coords: np.ndarray,
        element_connectivity: np.ndarray,
        body_force_fn: Callable[[float], float],
        n_gauss: int = 2
    ) -> np.ndarray:
        n_nodes = len(node_coords)
        n_elements = element_connectivity.shape[0]
        F_global = np.zeros(n_nodes)

        for e in range(n_elements):
            node_ids = element_connectivity[e]
            x_elem = node_coords[node_ids]

            # Compute the element body force vector
            f_elem = element_body_force_vector_1D(x_elem, body_force_fn, n_gauss)

            # Assemble into the global force vector
            for a_local, a_global in enumerate(node_ids):
                F_global[a_global] += f_elem[a_local]

        return F_global

failure_examples:
  "wrong_assembly_indexing": |
    def assemble_global_body_force_vector_linear_elastic_1D(
        node_coords: np.ndarray,
        element_connectivity: np.ndarray,
        body_force_fn: Callable[[float], float],
        n_gauss: int = 2
    ) -> np.ndarray:
        # Wrong! Incorrect indexing in assembly
        n_nodes = len(node_coords)
        n_elements = element_connectivity.shape[0]
        F_global = np.zeros(n_nodes)

        for e in range(n_elements):
            node_ids = element_connectivity[e]
            x_elem = node_coords[node_ids]

            f_elem = element_body_force_vector_1D(x_elem, body_force_fn, n_gauss)

            # Wrong! Always uses indices [0,1] regardless of actual connectivity
            F_global[0:2] += f_elem

        return F_global
        
  "missing_element_loop": |
    def assemble_global_body_force_vector_linear_elastic_1D(
        node_coords: np.ndarray,
        element_connectivity: np.ndarray,
        body_force_fn: Callable[[float], float],
        n_gauss: int = 2
    ) -> np.ndarray:
        # Wrong! Only processes first element
        n_nodes = len(node_coords)
        F_global = np.zeros(n_nodes)

        # Wrong! Missing loop over elements
        e = 0
        node_ids = element_connectivity[e]
        x_elem = node_coords[node_ids]

        f_elem = element_body_force_vector_1D(x_elem, body_force_fn, n_gauss)

        for a_local, a_global in enumerate(node_ids):
            F_global[a_global] += f_elem[a_local]

        return F_global
        
  "no_assembly_accumulation": |
    def assemble_global_body_force_vector_linear_elastic_1D(
        node_coords: np.ndarray,
        element_connectivity: np.ndarray,
        body_force_fn: Callable[[float], float],
        n_gauss: int = 2
    ) -> np.ndarray:
        # Wrong! Overwrites instead of accumulating
        n_nodes = len(node_coords)
        n_elements = element_connectivity.shape[0]
        F_global = np.zeros(n_nodes)

        for e in range(n_elements):
            node_ids = element_connectivity[e]
            x_elem = node_coords[node_ids]

            f_elem = element_body_force_vector_1D(x_elem, body_force_fn, n_gauss)

            # Wrong! Uses = instead of += (overwrites previous contributions)
            for a_local, a_global in enumerate(node_ids):
                F_global[a_global] = f_elem[a_local]

        return F_global
        
  "wrong_force_function_usage": |
    def assemble_global_body_force_vector_linear_elastic_1D(
        node_coords: np.ndarray,
        element_connectivity: np.ndarray,
        body_force_fn: Callable[[float], float],
        n_gauss: int = 2
    ) -> np.ndarray:
        # Wrong! Uses constant force instead of provided function
        n_nodes = len(node_coords)
        n_elements = element_connectivity.shape[0]
        F_global = np.zeros(n_nodes)

        for e in range(n_elements):
            node_ids = element_connectivity[e]
            x_elem = node_coords[node_ids]

            # Wrong! Uses lambda x: 1.0 instead of body_force_fn
            constant_force = lambda x: 1.0
            f_elem = element_body_force_vector_1D(x_elem, constant_force, n_gauss)

            for a_local, a_global in enumerate(node_ids):
                F_global[a_global] += f_elem[a_local]

        return F_global

# ============================================================================
# Evaluation configuration
# ============================================================================

reference_verification:
  test_cases:
    # Single element cases
    - input:
        node_coords: [0.0, 2.0]
        element_connectivity: [[0, 1]]
        body_force_fn: "lambda x: 10.0"
        n_gauss: 2
      tolerance: 1e-12

    - input:
        node_coords: [0.0, 1.0]
        element_connectivity: [[0, 1]]
        body_force_fn: "lambda x: 5.0"
        n_gauss: 1
      tolerance: 1e-12

    - input:
        node_coords: [-1.0, 1.0]
        element_connectivity: [[0, 1]]
        body_force_fn: "lambda x: x"
        n_gauss: 3
      tolerance: 1e-12

    # Two element cases
    - input:
        node_coords: [0.0, 1.0, 2.0]
        element_connectivity: [[0, 1], [1, 2]]
        body_force_fn: "lambda x: 5.0"
        n_gauss: 2
      tolerance: 1e-12

    - input:
        node_coords: [0.0, 0.5, 1.5]
        element_connectivity: [[0, 1], [1, 2]]
        body_force_fn: "lambda x: 2.0"
        n_gauss: 1
      tolerance: 1e-12

    # Three element cases with different force functions
    - input:
        node_coords: [0.0, 1.0, 3.0, 4.0]
        element_connectivity: [[0, 1], [1, 2], [2, 3]]
        body_force_fn: "lambda x: 8.0"
        n_gauss: 2
      tolerance: 1e-12

    - input:
        node_coords: [0.0, 1.0, 3.0, 4.0]
        element_connectivity: [[0, 1], [1, 2], [2, 3]]
        body_force_fn: "lambda x: x"
        n_gauss: 2
      tolerance: 1e-10

    - input:
        node_coords: [0.0, 1.0, 3.0, 4.0]
        element_connectivity: [[0, 1], [1, 2], [2, 3]]
        body_force_fn: "lambda x: 0.0"
        n_gauss: 2
      tolerance: 1e-15

    # Four element case
    - input:
        node_coords: [0.0, 1.0, 2.0, 3.0, 4.0]
        element_connectivity: [[0, 1], [1, 2], [2, 3], [3, 4]]
        body_force_fn: "lambda x: 3.0"
        n_gauss: 2
      tolerance: 1e-12

    # Different integration rules with polynomial forces
    - input:
        node_coords: [0.0, 1.0, 2.0]
        element_connectivity: [[0, 1], [1, 2]]
        body_force_fn: "lambda x: x**2"
        n_gauss: 3
      tolerance: 1e-10

test_efficacy_verification:
  expected_failures:
    - failure_type: "wrong_assembly_indexing"
      test_function: "test_global_body_force_single_element"
    - failure_type: "wrong_assembly_indexing"
      test_function: "test_global_body_force_two_elements"
    - failure_type: "missing_element_loop"
      test_function: "test_global_body_force_two_elements"
    - failure_type: "missing_element_loop"
      test_function: "test_global_body_force_properties"
    - failure_type: "no_assembly_accumulation"
      test_function: "test_global_body_force_two_elements"
    - failure_type: "no_assembly_accumulation"
      test_function: "test_global_body_force_properties"
    - failure_type: "wrong_force_function_usage"
      test_function: "test_global_body_force_properties"