# Tier 1 Task Template
# Filename should match task_id: T1_FE_002.yaml
# Environment: Uses tier1_standard (see environments/tier1_environment.yaml)

# ============================================================================
# Task metadata
# ============================================================================
task_id: "T1_FE_002"
category: "FE"
subcategory: "material_assignment"
title: "1D Element Property Assignment"
short_description: "Assign linear elastic material properties (E, A) to 1D finite elements based on spatial regions."

version: "1.0"
created_date: "2025-06-18"
created_by: "elejeune11"

# ============================================================================
# Task specification -- note this forms the main LLM prompt
# ============================================================================

prompt: |
  Implement a function that assigns linear elastic material properties to finite elements based on their spatial location within defined material regions.
  
  The function takes a list of material property dictionaries, where each dictionary must contain:
  {
      "coord_min": float,
      "coord_max": float, 
      "E": float,
      "A": float
  }
  
  The function should assign Young's modulus (E) and cross-sectional area (A) to each element by determining which material region contains the element's center coordinate.
  
  The assignment should satisfy:
  - Each element is assigned properties based on its center coordinate
  - Elements must be assigned to exactly one material region
  - "First match wins" for overlapping regions
  - All elements must be covered by at least one region (no gaps allowed)
  - Function should raise appropriate errors for uncovered elements
  
  Include comprehensive unit tests that verify correct assignment for single regions, multiple regions, boundary conditions, and error cases.

expected_function_name: "assign_element_props_linear_elastic_1D"
include_tests: true
expected_test_functions: ["test_single_material_region", "test_multiple_material_regions", "test_boundary_conditions_and_edge_cases"]

function_signature:
  parameters: ["prop_list", "node_coords", "element_connectivity"]
  parameter_types: ["List[Dict[str, float]]", "np.ndarray", "np.ndarray"]
  return_shape: "(2,)"

task_dependencies:
  required_functions: []

# ============================================================================
# Reference solutions and failure examples for evaluation testing
# ============================================================================

reference_solution:
  code: |
    def assign_element_props_linear_elastic_1D(
        prop_list: List[Dict[str, float]],
        node_coords: np.ndarray,
        element_connectivity: np.ndarray
    ) -> np.ndarray:
        """
        Assign per-element linear elastic properties (E, A) for multiple material regions.

        Parameters:
            prop_list (List[Dict]): Each dict must contain:
                {
                    "coord_min": float,
                    "coord_max": float,
                    "E": float,
                    "A": float
                }
            node_coords (np.ndarray): Coordinates of all nodes, shape (n_nodes,)
            element_connectivity (np.ndarray): Element connectivity (n_elements, 2)

        Returns:
            np.ndarray: Array containing [E_vector, A_vector] (both shape: n_elements,)
        """
        n_elements = element_connectivity.shape[0]
        E_vector = np.zeros(n_elements)
        A_vector = np.zeros(n_elements)

        for i in range(n_elements):
            node_indices = element_connectivity[i]
            x1, x2 = node_coords[node_indices[0]], node_coords[node_indices[1]]
            x_center = 0.5 * (x1 + x2)

            assigned = False
            for region in prop_list:
                if region["coord_min"] <= x_center <= region["coord_max"]:
                    E_vector[i] = region["E"]
                    A_vector[i] = region["A"]
                    assigned = True
                    break  # First match wins

            if not assigned:
                raise ValueError(f"Element {i} centered at x = {x_center:.3f} is not assigned to any material region.")

        return np.array([E_vector, A_vector], dtype=object)

failure_examples:
  "uses_node_coords_instead_of_center": |
    def assign_element_props_linear_elastic_1D(
        prop_list: List[Dict[str, float]],
        node_coords: np.ndarray,
        element_connectivity: np.ndarray
    ) -> np.ndarray:
        # Wrong! Uses first node coordinate instead of element center
        n_elements = element_connectivity.shape[0]
        E_vector = np.zeros(n_elements)
        A_vector = np.zeros(n_elements)

        for i in range(n_elements):
            node_indices = element_connectivity[i]
            x_test = node_coords[node_indices[0]]  # Should use center, not first node

            assigned = False
            for region in prop_list:
                if region["coord_min"] <= x_test <= region["coord_max"]:
                    E_vector[i] = region["E"]
                    A_vector[i] = region["A"]
                    assigned = True
                    break

            if not assigned:
                raise ValueError(f"Element {i} is not assigned to any material region.")

        return np.array([E_vector, A_vector], dtype=object)
        
  "no_error_on_unassigned": |
    def assign_element_props_linear_elastic_1D(
        prop_list: List[Dict[str, float]],
        node_coords: np.ndarray,
        element_connectivity: np.ndarray
    ) -> np.ndarray:
        # Wrong! Doesn't raise error for unassigned elements, uses default values
        n_elements = element_connectivity.shape[0]
        E_vector = np.zeros(n_elements)
        A_vector = np.zeros(n_elements)

        for i in range(n_elements):
            node_indices = element_connectivity[i]
            x1, x2 = node_coords[node_indices[0]], node_coords[node_indices[1]]
            x_center = 0.5 * (x1 + x2)

            assigned = False
            for region in prop_list:
                if region["coord_min"] <= x_center <= region["coord_max"]:
                    E_vector[i] = region["E"]
                    A_vector[i] = region["A"]
                    assigned = True
                    break

            # Wrong! Should raise error, but instead uses default zero values
            if not assigned:
                E_vector[i] = 1.0  # Default fallback instead of error
                A_vector[i] = 1.0

        return np.array([E_vector, A_vector], dtype=object)
        
  "last_match_wins": |
    def assign_element_props_linear_elastic_1D(
        prop_list: List[Dict[str, float]],
        node_coords: np.ndarray,
        element_connectivity: np.ndarray
    ) -> np.ndarray:
        # Wrong! Uses "last match wins" instead of "first match wins"
        n_elements = element_connectivity.shape[0]
        E_vector = np.zeros(n_elements)
        A_vector = np.zeros(n_elements)

        for i in range(n_elements):
            node_indices = element_connectivity[i]
            x1, x2 = node_coords[node_indices[0]], node_coords[node_indices[1]]
            x_center = 0.5 * (x1 + x2)

            assigned = False
            for region in prop_list:
                if region["coord_min"] <= x_center <= region["coord_max"]:
                    E_vector[i] = region["E"]
                    A_vector[i] = region["A"]
                    assigned = True
                    # Wrong! Missing break - continues to check all regions

            if not assigned:
                raise ValueError(f"Element {i} centered at x = {x_center:.3f} is not assigned to any material region.")

        return np.array([E_vector, A_vector], dtype=object)

# ============================================================================
# Evaluation configuration
# ============================================================================

reference_verification:
  test_cases:
    # 1 ─ Single-material bar (0 → 3 m)
    - input:
        prop_list:
          - coord_min: 0.0
            coord_max: 3.0
            E: 2.0e11      # 200 GPa
            A: 0.01
        node_coords: [0.0, 1.0, 2.0, 3.0]
        element_connectivity: [[0, 1], [1, 2], [2, 3]]
      tolerance: 1e-12

    # 2 ─ Two-material bar (0 → 4 m)
    - input:
        prop_list:
          - coord_min: 0.0
            coord_max: 2.0
            E: 7.0e10      # 70 GPa
            A: 0.005
          - coord_min: 2.0
            coord_max: 4.0
            E: 2.0e11      # 200 GPa
            A: 0.010
        node_coords: [0.0, 1.0, 2.0, 3.0, 4.0]
        element_connectivity: [[0, 1], [1, 2], [2, 3], [3, 4]]
      tolerance: 1e-12

    # 3 ─ Two-segment bar (0 → 3 m)
    - input:
        prop_list:
          - coord_min: 0.0
            coord_max: 1.5
            E: 1.0e11
            A: 0.01
          - coord_min: 1.5
            coord_max: 3.0
            E: 2.0e11
            A: 0.02
        node_coords: [0.0, 1.0, 2.0, 3.0]
        element_connectivity: [[0, 1], [1, 2], [2, 3]]
      tolerance: 1e-12

    # 4 ─ Single two-node element (0 → 1 m)
    - input:
        prop_list:
          - coord_min: 0.0
            coord_max: 1.0
            E: 1.0e11
            A: 0.01
        node_coords: [0.0, 1.0]
        element_connectivity: [[0, 1]]
      tolerance: 1e-12

    # 5 ─ Three-segment bar (-1 → 2 m) with varying A & E
    - input:
        prop_list:
          - coord_min: -1.0
            coord_max: 0.0
            E: 5.0e10
            A: 0.008
          - coord_min: 0.0
            coord_max: 1.0
            E: 1.5e11
            A: 0.012
          - coord_min: 1.0
            coord_max: 2.0
            E: 2.5e11
            A: 0.016
        node_coords: [-1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0]
        element_connectivity:
          - [0, 1]
          - [1, 2]
          - [2, 3]
          - [3, 4]
          - [4, 5]
          - [5, 6]
      tolerance: 1e-12

test_efficacy_verification:
  expected_failures:
    - failure_type: "uses_node_coords_instead_of_center"
      test_function: "test_multiple_material_regions"
    - failure_type: "no_error_on_unassigned"
      test_function: "test_boundary_conditions_and_edge_cases"
    - failure_type: "last_match_wins"
      test_function: "test_boundary_conditions_and_edge_cases"