# Tier 1 Task Template
# Filename should match task_id: T1_FE_008.yaml
# Environment: Uses tier1_standard (see environments/tier1_environment.yaml)

# ============================================================================
# Task metadata
# ============================================================================
task_id: "T1_FE_008"
category: "FE"
subcategory: "solver"
title: "Complete 1D Linear Elastic Finite Element Solver"
short_description: "Complete finite element solver for 1D linear elastic problems with mixed boundary conditions."

version: "1.0"
created_date: "2025-06-19"
created_by: "elejeune11"

# ============================================================================
# Task specification -- note this forms the main LLM prompt
# ============================================================================

prompt: |
  Implement a complete finite element solver for 1D linear elastic problems that handles the entire solution pipeline from material assignment through boundary condition application to final solution.
  
  The solver must integrate all finite element components:
  1. Material property assignment to elements based on coordinate ranges
  2. Global stiffness matrix assembly from element contributions
  3. Global body force vector assembly from distributed loads
  4. Neumann boundary condition application (point loads at specified coordinates)
  5. Dirichlet boundary condition handling (prescribed displacements)
  6. System solution with proper partitioning and reaction computation
  
  The function should satisfy:
  - Correct handling of multi-material systems with spatially varying properties
  - Support for arbitrary body force functions f(x)
  - Robust coordinate-based boundary condition specification with tolerance matching
  - Proper application of both Dirichlet (displacement) and Neumann (force) boundary conditions
  - Accurate solution of the final linear system with reaction force computation
  - Global equilibrium verification: sum of reactions + applied loads = 0
  - Physical behavior verification for standard loading cases
  
  Function input parameter definitions are:
    node_coords: 1D array of node coordinates (n_nodes,)
    element_connectivity: 2D array of element node connections (n_elements, 2)
    prop_list: List of material property dictionaries with keys "coord_min", "coord_max", "E", "A"
    body_force_fn: Callable function f(x) defining distributed body force per unit length
    dirichlet_BC_locations: List of x-coordinates where displacements are prescribed
    prescribed_displacements: List of displacement values at Dirichlet locations
    neumann_bc_list: Optional list of point load dictionaries with keys "x_location", "load_mag"
    n_gauss: Number of Gauss integration points per element
  
  Returns array containing:
    x: Full displacement vector (n_nodes,)
    R: Reaction forces at Dirichlet boundary nodes (same order as dirichlet_BC_locations)
  
  Include comprehensive unit tests covering zero load cases, analytical solutions for uniform extension, multi-material systems, and various combinations of Neumann boundary conditions.

expected_function_name: "solve_linear_elastic_1D"
include_tests: true
expected_test_functions: ["test_no_load", "test_uniform_extension_analytical", "test_multi_material_system", "test_neumann_point_load", "test_multiple_neumann_loads"]

function_signature:
  parameters: ["node_coords", "element_connectivity", "prop_list", "body_force_fn", "dirichlet_BC_locations", "prescribed_displacements", "neumann_bc_list", "n_gauss"]
  parameter_types: ["np.ndarray", "np.ndarray", "List[Dict[str, float]]", "Callable[[float], float]", "List[float]", "List[float]", "List[Dict[str, float]]", "int"]
  return_shape: "np.ndarray (dtype=object, containing [x, R])"

task_dependencies:
  required_functions:
    - source_task: "T1_FE_002"
    - source_task: "T1_FE_005"
    - source_task: "T1_FE_006"
    - source_task: "T1_FE_007"

# ============================================================================
# Reference solutions and failure examples for evaluation testing
# ============================================================================

reference_solution:
  code: |
    def solve_linear_elastic_1D(
        node_coords: np.ndarray,
        element_connectivity: np.ndarray,
        prop_list: List[Dict[str, float]],
        body_force_fn: Callable[[float], float],
        dirichlet_BC_locations: List[float],
        prescribed_displacements: List[float],
        neumann_bc_list: List[Dict[str, float]] = None,
        n_gauss: int = 2
    ) -> np.ndarray:
        """
        Solve a 1D linear elastic finite element problem.

        Parameters:
            node_coords (np.ndarray): Node coordinates (n_nodes,)
            element_connectivity (np.ndarray): Element connectivity (n_elements, 2)
            prop_list (List[Dict]): List of material regions, each with keys:
                "coord_min", "coord_max", "E", "A"
            body_force_fn (Callable): Function f(x) for body force
            dirichlet_BC_locations (List[float]): Positions where displacements are prescribed
            prescribed_displacements (List[float]): Values of displacements at those positions
            neumann_bc_list (List[Dict]): Each dict must contain:
                {
                    "x_location": float,  # coordinate of the node
                    "load_mag": float     # magnitude of point load (positive = outward)
                }
            n_gauss (int): Number of Gauss points for numerical integration

        Returns:
            np.ndarray:
                - x (np.ndarray): Displacement vector (n_nodes,)
                - R (np.ndarray): Reaction forces at Dirichlet BC nodes
        """
        # Assign material properties to elements
        E_vector, A_vector = assign_element_props_linear_elastic_1D(
            prop_list, node_coords, element_connectivity
        )

        # Assemble global stiffness matrix
        K_global = assemble_global_stiffness_matrix_linear_elastic_1D(
            node_coords, element_connectivity, E_vector, A_vector, n_gauss
        )

        # Assemble global body force vector
        F_global = assemble_global_body_force_vector_linear_elastic_1D(
            node_coords, element_connectivity, body_force_fn, n_gauss
        )

        # Apply Neumann boundary conditions (point loads)
        tol = 1e-8
        if neumann_bc_list is not None:
            for bc in neumann_bc_list:
                x_target = bc["x_location"]
                load = bc["load_mag"]
                
                matches = np.where(np.abs(node_coords - x_target) < tol)[0]
                
                if len(matches) == 0:
                    raise ValueError(f"No node found at x = {x_target} within tolerance {tol}")
                elif len(matches) > 1:
                    raise ValueError(f"Multiple nodes found near x = {x_target}; check mesh or tolerance.")
                
                F_global[matches[0]] += load

        # Map Dirichlet BC locations to node indices
        dirichlet_BC_nodes = []
        for x_target in dirichlet_BC_locations:
            matches = np.where(np.abs(node_coords - x_target) < tol)[0]
            
            if len(matches) == 0:
                raise ValueError(f"No node found at x = {x_target} within tolerance {tol}")
            elif len(matches) > 1:
                raise ValueError(f"Multiple nodes found near x = {x_target}; check mesh spacing or reduce tolerance.")
            
            dirichlet_BC_nodes.append(matches[0])

        # Solve for displacements and reactions
        x, R = solve_matrix_eqn(
            K_global, F_global, dirichlet_BC_nodes, prescribed_displacements
        )

        return np.array([x, R], dtype=object)
        
  "wrong_assembly_order": |

failure_examples:
  "missing_neumann_application": |
    def solve_linear_elastic_1D(
        node_coords: np.ndarray,
        element_connectivity: np.ndarray,
        prop_list: List[Dict[str, float]],
        body_force_fn: Callable[[float], float],
        dirichlet_BC_locations: List[float],
        prescribed_displacements: List[float],
        neumann_bc_list: List[Dict[str, float]] = None,
        n_gauss: int = 2
    ) -> np.ndarray:
        # Wrong! Doesn't apply Neumann boundary conditions
        E_vector, A_vector = assign_element_props_linear_elastic_1D(
            prop_list, node_coords, element_connectivity
        )

        K_global = assemble_global_stiffness_matrix_linear_elastic_1D(
            node_coords, element_connectivity, E_vector, A_vector, n_gauss
        )

        F_global = assemble_global_body_force_vector_linear_elastic_1D(
            node_coords, element_connectivity, body_force_fn, n_gauss
        )

        # Wrong! Skips Neumann BC application entirely
        # Missing: point load application to F_global

        dirichlet_BC_nodes = []
        tol = 1e-8
        for x_target in dirichlet_BC_locations:
            matches = np.where(np.abs(node_coords - x_target) < tol)[0]
            dirichlet_BC_nodes.append(matches[0])

        x, R = solve_matrix_eqn(
            K_global, F_global, dirichlet_BC_nodes, prescribed_displacements
        )

        return np.array([x, R], dtype=object)
        
  "wrong_bc_mapping": |
    def solve_linear_elastic_1D(
        node_coords: np.ndarray,
        element_connectivity: np.ndarray,
        prop_list: List[Dict[str, float]],
        body_force_fn: Callable[[float], float],
        dirichlet_BC_locations: List[float],
        prescribed_displacements: List[float],
        neumann_bc_list: List[Dict[str, float]] = None,
        n_gauss: int = 2
    ) -> np.ndarray:
        # Wrong! Incorrect boundary condition coordinate mapping
        E_vector, A_vector = assign_element_props_linear_elastic_1D(
            prop_list, node_coords, element_connectivity
        )

        K_global = assemble_global_stiffness_matrix_linear_elastic_1D(
            node_coords, element_connectivity, E_vector, A_vector, n_gauss
        )

        F_global = assemble_global_body_force_vector_linear_elastic_1D(
            node_coords, element_connectivity, body_force_fn, n_gauss
        )

        if neumann_bc_list is not None:
            for bc in neumann_bc_list:
                x_target = bc["x_location"]
                load = bc["load_mag"]
                # Wrong! Uses array index instead of coordinate matching
                node_idx = int(x_target)  # Assumes x_location is node index
                if 0 <= node_idx < len(node_coords):
                    F_global[node_idx] += load

        # Wrong! Uses coordinate values as indices instead of finding matching nodes
        dirichlet_BC_nodes = []
        for x_target in dirichlet_BC_locations:
            idx = int(x_target)  # Wrong! Treats coordinate as index
            if 0 <= idx < len(node_coords):
                dirichlet_BC_nodes.append(idx)

        x, R = solve_matrix_eqn(
            K_global, F_global, dirichlet_BC_nodes, prescribed_displacements
        )

        return np.array([x, R], dtype=object)
        
  "missing_material_assignment": |
    def solve_linear_elastic_1D(
        node_coords: np.ndarray,
        element_connectivity: np.ndarray,
        prop_list: List[Dict[str, float]],
        body_force_fn: Callable[[float], float],
        dirichlet_BC_locations: List[float],
        prescribed_displacements: List[float],
        neumann_bc_list: List[Dict[str, float]] = None,
        n_gauss: int = 2
    ) -> np.ndarray:
        # Wrong! Uses constant material properties instead of prop_list
        n_elements = element_connectivity.shape[0]
        # Wrong! Uses first material for all elements
        E_vector = np.full(n_elements, prop_list[0]["E"])
        A_vector = np.full(n_elements, prop_list[0]["A"])

        K_global = assemble_global_stiffness_matrix_linear_elastic_1D(
            node_coords, element_connectivity, E_vector, A_vector, n_gauss
        )

        F_global = assemble_global_body_force_vector_linear_elastic_1D(
            node_coords, element_connectivity, body_force_fn, n_gauss
        )

        tol = 1e-8
        if neumann_bc_list is not None:
            for bc in neumann_bc_list:
                x_target = bc["x_location"]
                load = bc["load_mag"]
                matches = np.where(np.abs(node_coords - x_target) < tol)[0]
                F_global[matches[0]] += load

        dirichlet_BC_nodes = []
        for x_target in dirichlet_BC_locations:
            matches = np.where(np.abs(node_coords - x_target) < tol)[0]
            dirichlet_BC_nodes.append(matches[0])

        x, R = solve_matrix_eqn(
            K_global, F_global, dirichlet_BC_nodes, prescribed_displacements
        )

        return np.array([x, R], dtype=object)
        
  "constant_force_bug": |
    def solve_linear_elastic_1D(
        node_coords: np.ndarray,
        element_connectivity: np.ndarray,
        prop_list: List[Dict[str, float]],
        body_force_fn: Callable[[float], float],
        dirichlet_BC_locations: List[float],
        prescribed_displacements: List[float],
        neumann_bc_list: List[Dict[str, float]] = None,
        n_gauss: int = 2
    ) -> np.ndarray:
        # Wrong! Always adds a constant force regardless of body_force_fn
        E_vector, A_vector = assign_element_props_linear_elastic_1D(
            prop_list, node_coords, element_connectivity
        )

        K_global = assemble_global_stiffness_matrix_linear_elastic_1D(
            node_coords, element_connectivity, E_vector, A_vector, n_gauss
        )

        F_global = assemble_global_body_force_vector_linear_elastic_1D(
            node_coords, element_connectivity, body_force_fn, n_gauss
        )

        # Wrong! Always adds spurious constant force
        F_global += 100.0  # Adds 100 N to every node

        tol = 1e-8
        if neumann_bc_list is not None:
            for bc in neumann_bc_list:
                x_target = bc["x_location"]
                load = bc["load_mag"]
                matches = np.where(np.abs(node_coords - x_target) < tol)[0]
                if len(matches) > 0:
                    F_global[matches[0]] += load

        dirichlet_BC_nodes = []
        for x_target in dirichlet_BC_locations:
            matches = np.where(np.abs(node_coords - x_target) < tol)[0]
            if len(matches) > 0:
                dirichlet_BC_nodes.append(matches[0])

        x, R = solve_matrix_eqn(
            K_global, F_global, dirichlet_BC_nodes, prescribed_displacements
        )

        return np.array([x, R], dtype=object)
    def solve_linear_elastic_1D(
        node_coords: np.ndarray,
        element_connectivity: np.ndarray,
        prop_list: List[Dict[str, float]],
        body_force_fn: Callable[[float], float],
        dirichlet_BC_locations: List[float],
        prescribed_displacements: List[float],
        neumann_bc_list: List[Dict[str, float]] = None,
        n_gauss: int = 2
    ) -> np.ndarray:
        # Wrong! Incorrect function call order but won't crash
        E_vector, A_vector = assign_element_props_linear_elastic_1D(
            prop_list, node_coords, element_connectivity
        )

        F_global = assemble_global_body_force_vector_linear_elastic_1D(
            node_coords, element_connectivity, body_force_fn, n_gauss
        )

        # Wrong! Assembles stiffness after force (unusual order)
        K_global = assemble_global_stiffness_matrix_linear_elastic_1D(
            node_coords, element_connectivity, E_vector, A_vector, n_gauss
        )

        # Wrong! Applies Neumann BCs before mapping Dirichlet nodes
        if neumann_bc_list is not None:
            tol = 1e-8
            for bc in neumann_bc_list:
                x_target = bc["x_location"]
                load = bc["load_mag"]
                matches = np.where(np.abs(node_coords - x_target) < tol)[0]
                if len(matches) > 0:
                    F_global[matches[0]] += load

        dirichlet_BC_nodes = []
        tol = 1e-8
        for x_target in dirichlet_BC_locations:
            matches = np.where(np.abs(node_coords - x_target) < tol)[0]
            if len(matches) > 0:
                dirichlet_BC_nodes.append(matches[0])

        x, R = solve_matrix_eqn(
            K_global, F_global, dirichlet_BC_nodes, prescribed_displacements
        )

        return np.array([x, R], dtype=object)

# ============================================================================
# Evaluation configuration
# ============================================================================

reference_verification:
  test_cases:
    # Zero load case
    - input:
        node_coords: [0.0, 1.0, 2.0]
        element_connectivity: [[0, 1], [1, 2]]
        prop_list:
          - coord_min: 0.0
            coord_max: 2.0
            E: 2.0e11
            A: 0.01
        body_force_fn: "lambda x: 0.0"
        dirichlet_BC_locations: [0.0]
        prescribed_displacements: [0.0]
        neumann_bc_list: null
        n_gauss: 2
      tolerance: 1e-12

    # Uniform extension with body force
    - input:
        node_coords: [0.0, 1.0, 2.0, 3.0]
        element_connectivity: [[0, 1], [1, 2], [2, 3]]
        prop_list:
          - coord_min: 0.0
            coord_max: 3.0
            E: 1.0e11
            A: 0.001
        body_force_fn: "lambda x: 1000.0"
        dirichlet_BC_locations: [0.0]
        prescribed_displacements: [0.0]
        neumann_bc_list: null
        n_gauss: 2
      tolerance: 1e-10

    # Point load case
    - input:
        node_coords: [0.0, 1.0, 2.0]
        element_connectivity: [[0, 1], [1, 2]]
        prop_list:
          - coord_min: 0.0
            coord_max: 2.0
            E: 2.0e11
            A: 0.01
        body_force_fn: "lambda x: 0.0"
        dirichlet_BC_locations: [0.0]
        prescribed_displacements: [0.0]
        neumann_bc_list:
          - x_location: 2.0
            load_mag: 1000.0
        n_gauss: 2
      tolerance: 1e-10

    # Multi-material system
    - input:
        node_coords: [0.0, 1.0, 2.0, 3.0, 4.0]
        element_connectivity: [[0, 1], [1, 2], [2, 3], [3, 4]]
        prop_list:
          - coord_min: 0.0
            coord_max: 2.0
            E: 5.0e10
            A: 0.01
          - coord_min: 2.0
            coord_max: 4.0
            E: 2.0e11
            A: 0.005
        body_force_fn: "lambda x: 100.0 * x"
        dirichlet_BC_locations: [0.0, 4.0]
        prescribed_displacements: [0.0, 0.1]
        neumann_bc_list: null
        n_gauss: 2
      tolerance: 1e-8

    # Multiple Neumann loads
    - input:
        node_coords: [0.0, 1.0, 2.0, 3.0]
        element_connectivity: [[0, 1], [1, 2], [2, 3]]
        prop_list:
          - coord_min: 0.0
            coord_max: 3.0
            E: 1.0e11
            A: 0.005
        body_force_fn: "lambda x: 0.0"
        dirichlet_BC_locations: [0.0, 3.0]
        prescribed_displacements: [0.0, 0.0]
        neumann_bc_list:
          - x_location: 1.0
            load_mag: 500.0
          - x_location: 2.0
            load_mag: -300.0
        n_gauss: 2
      tolerance: 1e-8

test_efficacy_verification:
  expected_failures:
    - failure_type: "constant_force_bug"
      test_function: "test_no_load"
    - failure_type: "missing_neumann_application"
      test_function: "test_neumann_point_load"
    - failure_type: "missing_neumann_application"
      test_function: "test_multiple_neumann_loads"
    - failure_type: "wrong_bc_mapping"
      test_function: "test_uniform_extension_analytical"
    - failure_type: "wrong_bc_mapping"
      test_function: "test_neumann_point_load"
    - failure_type: "wrong_bc_mapping"
      test_function: "test_multi_material_system"
    - failure_type: "wrong_bc_mapping"
      test_function: "test_multiple_neumann_loads"
    - failure_type: "missing_material_assignment"
      test_function: "test_multi_material_system"
    - failure_type: "wrong_assembly_order"
      test_function: "test_uniform_extension_analytical"
    - failure_type: "wrong_assembly_order"
      test_function: "test_neumann_point_load"
    - failure_type: "wrong_assembly_order"
      test_function: "test_multiple_neumann_loads"