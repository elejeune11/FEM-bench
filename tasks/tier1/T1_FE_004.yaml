# Tier 1 Task Template
# Filename should match task_id: T1_FE_004.yaml
# Environment: Uses tier1_standard (see environments/tier1_environment.yaml)

# ============================================================================
# Task metadata
# ============================================================================
task_id: "T1_FE_004"
category: "FE"
subcategory: "body_force"
title: "1D Element Body Force Vector"
short_description: "Compute the element body force vector for a 1D finite element using numerical integration and shape functions."

version: "1.0"
created_date: "2025-06-19"
created_by: "elejeune11"

# ============================================================================
# Task specification -- note this forms the main LLM prompt
# ============================================================================

prompt: |
  Implement a function that computes the element body force vector for a 1D finite element using shape functions and numerical integration with isoparametric mapping.
  
  The element body force vector represents the contribution of distributed body forces (e.g., gravity, thermal loads) to the element's nodal forces. It is computed using the weak form.
  
  The function should satisfy:
  - Correct vector shape (2,) for 2-node linear element
  - Total force conservation over element
  - Exact integration for polynomial body forces up to degree 1 (with sufficient Gauss points)
  - Proper coordinate mapping from reference to physical element
  
  Function input parameter definitions are:
    x_elem: Element node coordinates [x1, x2]
    body_force_fn: Function f(x) that returns scalar body force at position x
    n_gauss: Number of Gauss quadrature points for numerical integration
  
  Include comprehensive unit tests that verify analytical comparisons for constant and linear body forces, and integration rule independence.

expected_function_name: "element_body_force_vector_1D"
include_tests: true
expected_test_functions: ["test_constant_body_force", "test_linear_body_force"]

function_signature:
  parameters: ["x_elem", "body_force_fn", "n_gauss"]
  parameter_types: ["np.ndarray", "callable", "int"]
  return_shape: "(2,)"

task_dependencies:
  required_functions:
    - source_task: "T1_NI_001"
    - source_task: "T1_SF_001"
    - source_task: "T1_SF_002"
    - source_task: "T1_FE_001"

# ============================================================================
# Reference solutions and failure examples for evaluation testing
# ============================================================================

reference_solution:
  code: |
    def element_body_force_vector_1D(
        x_elem: np.ndarray,
        body_force_fn,
        n_gauss: int = 2
    ) -> np.ndarray:
        fe = np.zeros(2)
        xi_points, weights = gauss_quadrature_1D(n_gauss)
        dN_dxi = shape_function_derivatives_1D_linear()

        for xi, w in zip(xi_points, weights):
            N = shape_functions_1D_linear(xi)
            J = compute_jacobian_1D(dN_dxi, x_elem)
            x_phys = np.dot(N, x_elem)
            f = body_force_fn(x_phys)
            fe += w * f * J * N  # N is shape (2,), f is scalar

        return fe

failure_examples:
  "missing_jacobian": |
    def element_body_force_vector_1D(
        x_elem: np.ndarray,
        body_force_fn,
        n_gauss: int = 2
    ) -> np.ndarray:
        # Wrong! Missing Jacobian - incorrect scaling
        fe = np.zeros(2)
        xi_points, weights = gauss_quadrature_1D(n_gauss)
        
        for xi, w in zip(xi_points, weights):
            N = shape_functions_1D_linear(xi)
            x_phys = np.dot(N, x_elem)
            f = body_force_fn(x_phys)
            fe += w * f * N  # Missing Jacobian

        return fe
        
  "wrong_coordinate_mapping": |
    def element_body_force_vector_1D(
        x_elem: np.ndarray,
        body_force_fn,
        n_gauss: int = 2
    ) -> np.ndarray:
        # Wrong! Using reference coordinate instead of physical coordinate
        fe = np.zeros(2)
        xi_points, weights = gauss_quadrature_1D(n_gauss)
        dN_dxi = shape_function_derivatives_1D_linear()
        
        for xi, w in zip(xi_points, weights):
            N = shape_functions_1D_linear(xi)
            J = compute_jacobian_1D(dN_dxi, x_elem)
            x_phys = xi  # Wrong - using reference coordinate
            f = body_force_fn(x_phys)
            fe += w * f * J * N

        return fe
        
  "integration_rule_dependent": |
    def element_body_force_vector_1D(
        x_elem: np.ndarray,
        body_force_fn,
        n_gauss: int = 2
    ) -> np.ndarray:
        # Wrong! Artificially depends on number of Gauss points
        fe = np.zeros(2)
        xi_points, weights = gauss_quadrature_1D(n_gauss)
        dN_dxi = shape_function_derivatives_1D_linear()
        
        for xi, w in zip(xi_points, weights):
            N = shape_functions_1D_linear(xi)
            J = compute_jacobian_1D(dN_dxi, x_elem)
            x_phys = np.dot(N, x_elem)
            f = body_force_fn(x_phys)
            fe += w * f * J * N * n_gauss  # Wrong scaling

        return fe
        
  "no_integration_loop": |
    def element_body_force_vector_1D(
        x_elem: np.ndarray,
        body_force_fn,
        n_gauss: int = 2
    ) -> np.ndarray:
        # Wrong! No proper integration, just evaluates at center
        fe = np.zeros(2)
        dN_dxi = shape_function_derivatives_1D_linear()
        
        N = shape_functions_1D_linear(0.0)  # Only at center
        J = compute_jacobian_1D(dN_dxi, x_elem)
        x_phys = np.dot(N, x_elem)
        f = body_force_fn(x_phys)
        fe = f * J * N * 2.0  # Wrong - not integrating

        return fe

# ============================================================================
# Evaluation configuration
# ============================================================================

reference_verification:
  test_cases:
    # 1 ─ Constant force, symmetric element
    - input:
        x_elem: [0.0, 2.0]
        body_force_fn: "lambda x: 100.0"
        n_gauss: 2
      tolerance: 1e-12

    # 2 ─ Linear force function, positive domain
    - input:
        x_elem: [1.0, 3.0]
        body_force_fn: "lambda x: x"
        n_gauss: 2
      tolerance: 1e-12

    # 3 ─ Short element, 1-point Gauss
    - input:
        x_elem: [0.0, 1.0]
        body_force_fn: "lambda x: 50.0"
        n_gauss: 1
      tolerance: 1e-12

    # 4 ─ Quadratic force, symmetric domain
    - input:
        x_elem: [-1.0, 1.0]
        body_force_fn: "lambda x: x**2"
        n_gauss: 3
      tolerance: 1e-12

test_efficacy_verification:
  expected_failures:
    - failure_type: "missing_jacobian"
      test_function: "test_constant_body_force"
    - failure_type: "missing_jacobian"  
      test_function: "test_linear_body_force"
    - failure_type: "wrong_coordinate_mapping"
      test_function: "test_linear_body_force"
    - failure_type: "integration_rule_dependent"
      test_function: "test_constant_body_force"
    - failure_type: "integration_rule_dependent"
      test_function: "test_linear_body_force"
    - failure_type: "no_integration_loop"
      test_function: "test_constant_body_force"
    - failure_type: "no_integration_loop"
      test_function: "test_linear_body_force"