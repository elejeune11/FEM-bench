# Python Task: Write Pytest Tests for a Function

Below is the function you are testing. Use its signature and docstring to understand its behavior.

## Only complete the test functions below:
def compute_integral_of_derivative_quad8(node_coords: np.ndarray, node_values: np.ndarray, num_gauss_pts: int) -> np.ndarray:
    """
    ∫_Ω (∇u) dΩ for a single quadratic quadrilateral element (scalar field only).

    Summary
    -------
    Computes the area integral of the physical gradient of a scalar field u
    over a Q8 8-node quadrilateral using Gauss–Legendre quadrature
    on the reference square Q = [-1,1]×[-1,1], mapped isoparametrically to Ω.

    Dependencies (only)
    -------------------
    - quad8_shape_functions_and_derivatives(xi) -> (N: (n,8,1), dN: (n,8,2))
      used to assemble J(ξ,η) = node_coords^T @ dN and det(J).
    - compute_physical_gradient_quad8(node_coords, node_values, xi, eta) -> (2, n_pts)
      gives [∂u/∂x; ∂u/∂y] at quadrature points.
    - quad_quadrature_2D(num_pts) -> (points: (num_pts,2), weights: (num_pts,))
      Gauss-Legendre points/weights for num_pts ∈ {1,4,9}.

    Parameters
    ----------
    node_coords : (8,2) float
        Physical coordinates in Q8 node order:
          1: (-1,-1), 2: ( 1,-1), 3: ( 1, 1), 4: (-1, 1),
          5: ( 0,-1), 6: ( 1, 0), 7: ( 0, 1), 8: (-1, 0)
    node_values : (8,) or (8,1) float
        Scalar nodal values for u. (If (8,1), it is squeezed.)
    num_gauss_pts : {1,4,9}
        Total quadrature points (1×1, 2×2, or 3×3).

    Returns
    -------
    integral : (2,) float
        [∫_Ω ∂u/∂x dΩ, ∫_Ω ∂u/∂y dΩ].
    """

## Your Goal:
Write pytest-style test functions that verify the correctness of the function above.

## Requirements:
- Use the exact test function names listed below
- Each test must accept a single argument: `fcn` — the function to test
- Use `assert` statements to check correctness
- Each test must include a descriptive docstring
- Do not include print statements, logging, or example usage
- Output only valid Python code — no explanations, markdown, or comments

## Function Signature:
## Test Functions to Implement:
- test_integral_of_derivative_quad8_identity_cubic: "Analytic check with identity mapping (reference element = physical element).
When x ≡ ξ and y ≡ η, the Jacobian is J = I with det(J) = 1, so the routine
integrates the physical gradient directly over Q = [-1, 1] × [-1, 1].
Using u(x, y) = x^3 + y^3 gives ∇u = [3x^2, 3y^2] and the exact integrals on Q are [4, 4].
A 2×2 Gauss rule (num_gauss_pts=4) is exact for this case; the test checks we recover [4, 4]."
- test_integral_of_derivative_quad8_affine_linear_field: "Analytic check with an affine geometric map and a linear field. We map the
reference square Q = [-1, 1] × [-1, 1] by [x, y]^T = A[ξ, η]^T + c. By placing
the eight node quad mid-edge nodes at the arithmetic midpoints of the mapped corners, the
isoparametric geometry is exactly affine, so the Jacobian is constant (J = A,
det(J) = det(A)). For the linear scalar field u(x, y) = α + βx + γy, the physical
gradient is constant ∇u = [β, γ], hence ∫_Ω ∇u dΩ = [β, γ] · Area(Ω). The area follows
from the mapping: Area(Ω) = ∫_Q det(J) dQ = det(A) · Area(Q) = 4 · |det(A)|, so
the exact result is [β, γ] · (4 · |det(A)|). Test to make sure the function matches
this analytical solution."
- test_integral_of_derivative_quad8_order_check_asymmetric_curved: "Test quadrature-order sensitivity on a deliberately curved, asymmetric mapping.
One approach is to keep the four corners on the reference square but displace the mid-edge
nodes asymmetrically, inducing a non-affine geometry (spatially varying J).
With fixed, non-symmetric nodal values, the FE integrand becomes high-order in (ξ, η), 
so a 3×3 rule should not coincide with 2×2 or 1×1.
The test asserts that increasing the rule to 3×3 changes the result."

# Output:
# Only return valid pytest test functions — no prose, markdown, or commentary.
