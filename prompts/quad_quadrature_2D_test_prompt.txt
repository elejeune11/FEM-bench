# Python Task: Write Pytest Tests for a Function

Below is the function you are testing. Use its signature and docstring to understand its behavior.

## Only complete the test functions below:
def quad_quadrature_2D(num_pts: int) -> Tuple[np.ndarray, np.ndarray]:
    """
    Return Gauss–Legendre quadrature points and weights for the
    reference square Q = { (xi, eta) : -1 <= xi <= 1, -1 <= eta <= 1 }.

    Supported rules (tensor products of 1D Gauss–Legendre):
      - 1 point  : 1×1   (exact for polynomials with degree ≤1 in each variable)
      - 4 points : 2×2   (exact for degree ≤3 in each variable)
      - 9 points : 3×3   (exact for degree ≤5 in each variable)

    Parameters
    ----------
    num_pts : int
        Total number of quadrature points (1, 4, or 9).

    Returns
    -------
    points : (num_pts, 2) float64 ndarray
        Quadrature points [xi, eta] on the reference square.
    weights : (num_pts,) float64 ndarray
        Quadrature weights corresponding to `points`. The sum of weights
        equals the area of Q, which is 4.0.

    Raises
    ------
    ValueError
        If `num_pts` is not one of {1, 4, 9}.
    """

## Your Goal:
Write pytest-style test functions that verify the correctness of the function above.

## Requirements:
- Use the exact test function names listed below
- Each test must accept a single argument: `fcn` — the function to test
- Use `assert` statements to check correctness
- Each test must include a descriptive docstring
- Do not include print statements, logging, or example usage
- Output only valid Python code — no explanations, markdown, or comments

## Function Signature:
## Test Functions to Implement:
- test_quad_quadrature_2D_invalid_inputs: "Test that quad_quadrature_2D rejects invalid numbers of points.

The quadrature rule only supports 1, 4, or 9 integration points.
Any other request should raise a ValueError."
- test_quad_quadrature_2D_basics: "Test basic structural properties of the quadrature rule for quads.

For each supported rule (1, 4, 9 points):
- The returned points and weights arrays have the correct shapes and dtypes.
- The weights sum to 4.0, which is the exact area of the reference square [-1,1] x [-1,1].
- All quadrature points lie inside the reference square, i.e.
  -1 <= x <= 1 and -1 <= y <= 1."
- test_quad_quadrature_2D_degree_exactness_1pt: "Validate the degree-exactness of the 1×1 Gauss–Legendre quadrature rule on the
reference square [-1,1]×[-1,1].

Background
----------
• The tensor-product 1-point rule places a single node at the center (0,0) with
  weight 4. This integrates exactly any polynomial that is at most degree 1
  in each variable, i.e. constants and linear terms in x or y.
• For higher-degree terms, the rule is no longer guaranteed to be exact.

What this test does
-------------------
1. Constructs a random affine polynomial P(x,y) = a00 + a10·x + a01·y.
   - Checks that the quadrature result matches the analytic integral.
2. Adds quadratic contributions (x², y², xy).
   - Demonstrates that the quadrature result deviates from the analytic value,
     confirming that the 1-point rule is not exact for degree ≥ 2.

Expected outcome
----------------
• Exactness assertions for monomials of degree ≤ 1 should pass.
• Non-exactness assertions for quadratics should fail the exactness check
  (i.e. the quadrature does not reproduce the analytic integrals)."
- test_quad_quadrature_2D_degree_exactness_2x2: "Validate the degree-exactness of the 2×2 Gauss–Legendre quadrature rule on [-1,1]×[-1,1].

Background
----------
• The 2-point Gauss–Legendre rule in 1D integrates exactly any polynomial up to degree 3.
  Taking the tensor product yields a 2×2 rule in 2D (4 points total), which is exact for
  any polynomial with degree ≤ 3 in each variable separately (i.e., cubic polynomials
  in x and y).
• It is not guaranteed to integrate quartic terms (degree 4 in either variable) exactly.

What this test does
-------------------
1. Builds a random polynomial P(x,y) = Σ a_ij x^i y^j for 0 ≤ i,j ≤ 3, i.e. all terms up
   to cubic in x and cubic in y. The quadrature approximation is compared to the analytic
   integral, the two results must match.
2. Extends the polynomial with quartic terms x^4 and y^4. For these terms the 2×2 rule
   is not exact, so the quadrature result is expected to deviate from the analytic integral.

Expected outcome
----------------
• Exactness assertions for all monomials with per-variable degree ≤ 3 should pass.
• Adding quartic terms should break exactness, and the mismatch is detected by the test."
- test_quad_quadrature_2D_degree_exactness_3x3: "Validate the degree-exactness of the 3×3 Gauss–Legendre quadrature rule on [-1,1]×[-1,1].

Background
----------
• The 3-point Gauss–Legendre rule in 1D integrates polynomials exactly up to degree 5.
  Taking the tensor product yields a 3×3 rule in 2D (9 points total), which is exact
  for any polynomial where the degree in each variable is ≤ 5.
• The rule is not guaranteed to integrate terms with degree 6 or higher in either variable.

What this test does
-------------------
1. Constructs a random polynomial P(x,y) = Σ a_ij x^i y^j with 0 ≤ i,j ≤ 5 (up to quintic
   terms in both variables). The quadrature approximation is compared to the analytic
   integral, the two results must match within tight tolerance.
2. Extends the polynomial with degree-6 contributions (x^6, y^6, x^4y^2). These exceed the
   rule’s guaranteed exactness, so the quadrature result is expected to deviate from the
   analytic integral.

Expected outcome
----------------
• Exactness assertions for all monomials with per-variable degree ≤ 5 should pass.
• Adding degree-6 terms should break exactness, and the mismatch is detected by the test."

# Output:
# Only return valid pytest test functions — no prose, markdown, or commentary.
