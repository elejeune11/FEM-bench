{
    "function_imports": ["numpy"],
    "test_imports": ["pytest"],
    "compute_1d_quadratic_shape_functions": "def compute_1d_quadratic_shape_functions(xi: float) -> (3,):\n    \"\"\"\n    Compute quadratic shape functions for 1D three-node element\n    \n    Args:\n        xi (float): Local coordinate in the range [-1, 1].\n    \n    Returns:\n        np.ndarray: Array of shape (3,) containing the quadratic shape function values.\n                    The functions satisfy N1(xi) + N2(xi) + N3(xi) = 1.\n    \"\"\"\n    N1 = 0.5 * xi * (xi - 1)\n    N2 = 1 - xi**2\n    N3 = 0.5 * xi * (xi + 1)\n    return np.array([N1, N2, N3])",
    "test_quadratic_partition": "def test_quadratic_partition():\n    \"\"\"Test that the quadratic shape functions satisfy the partition of unity.\"\"\"\n    xis = np.linspace(-1, 1, 5)\n    for xi in xis:\n        shape_functions = compute_1d_quadratic_shape_functions(xi)\n        assert abs(shape_functions.sum() - 1.0) < 1e-8, f\"Partition of unity failed at xi={xi}\"",
    "test_quadratic_interpolation": "def test_quadratic_interpolation():\n    \"\"\"Test the interpolation property at nodes xi = -1, 0, and 1.\"\"\"\n    # At xi = -1, expect [1, 0, 0]\n    assert np.allclose(compute_1d_quadratic_shape_functions(-1), [1.0, 0.0, 0.0]), \"Incorrect interpolation at xi=-1\"\n    # At xi = 0, expect [0, 1, 0]\n    assert np.allclose(compute_1d_quadratic_shape_functions(0), [0.0, 1.0, 0.0]), \"Incorrect interpolation at xi=0\"\n    # At xi = 1, expect [0, 0, 1]\n    assert np.allclose(compute_1d_quadratic_shape_functions(1), [0.0, 0.0, 1.0]), \"Incorrect interpolation at xi=1\""
  }